<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Datenbanken 1 - Kapitel 4 - SQL</title>

		<link rel="stylesheet" href="reveal.js/css/reset.css">
		<link rel="stylesheet" href="reveal.js/css/reveal.css">

        <link rel="stylesheet" href="src/slides.css">
        <link rel="stylesheet" href="src/sql.css">

		<link rel="stylesheet" href="src/layout.css">
        <link rel="stylesheet" href="lib/joint.min.css" />
        <link rel="stylesheet" href="src/erd.css" />

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="src/rainbow.css">

        <!--<script defer src="lib/fontawesome.all.min.js"/>-->
        <link href="lib/fontawesome.all.min.css" rel="stylesheet">
        <style> .reveal i.fa { font-family:FontAwesome; font-style: normal; } </style>



		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
            <div id="header"></div>
            <div id="footer"></div>
			<div class="slides">
                    <section>
                            <h4 style="text-align:center"><b>Dr.-Ing. Johannes Schildgen</b><br>
                            <a href="mailto:johannes.schildgen@h-da.de">johannes.schildgen@h-da.de</a></h4>
                            <h1>Datenbanken 1</h1>
                            <h3>Kapitel 4: SQL</h3>
                            <h4 style="text-align:center">2019-10-28</h4>
                            <img src="img/ccby.png" height="60px" style="position: absolute; left:0px; border:0; bottom:-160px;">
                            <img src="img/hda.png" height="60px" style="position: absolute; right:0px; border:0; bottom:-160px; box-shadow:none">
                        </section>
                        <section>
                            <h2>SQL...</h2>
                            <div class="trackinfo"><i class="fas fa-headphones"></i> 33, 36</div>
                            <ul class="small">
                                <li>... ist der Nachfolger von SEQUEL (Structured English Query Language),</li>
                                <li>... wurde in den 1970er-Jahren entworfen,</li>
                                <li>... ist ein eigenständiger Begriff,</li>
                                <li>... wird manchmal als Abkürzung für Structured Query Language gesehen,</li>
                                <li>... ist eine standardisierte Anfragefrage für strukturierte Datenbanken,</li>
                                <li>... ist größtenteils unabhängig vom verwendeten relationalen DBMS (RDBMS).</li>
                            </ul>
                            <aside class="notes">SQL ist eine leicht zu erlernende aber trotzdem sehr mächtige Anfragesprache für alle Aufgaben bei der Arbeit mit relationalen Datenbanken. Gelegentliche Benutzer können schnell simple Abfragen schreiben, erfahrene Benutzer können sich fortgeschrittenen Sprachkonstrukten bedienen. Der SQL-Standard ist ein ISO-Standard und wird ständig weiterentwickelt (SQL92, ..., SQL:2016). Dadurch, dass die Sprache standardisiert ist, verwenden alle populären relationalen Datenbankmanagementsysteme als Anfragesprache SQL. Dies macht Anwendungen portabel (Wechsel zu anderem DBMS) und es reduziert den Lernaufwand für die Anwender.</aside>
                        </section>
                        
                        <section>
                            <h2>Populäre RDBMS</h2>
                            <div class="trackinfo"><i class="fas fa-headphones"></i> 34-35</div>
                            <p class="small">Quelle: db-engines.com/de/ranking</p>
                            <ol>
                                <li>Oracle</li>
                                <li>MySQL</li>
                                <li>Microsoft SQL Server</li>
                                <li>PostgreSQL <span class="fragment small">&leftarrow; verwenden wir im Rahmen dieser Vorlesung</span></li>
                                <li>IBM DB2</li>
                                <li>SQLite</li>
                                <li>MariaDB</li>
                            </ol>
                            <aside class="notes">Die hier dargestellte Liste ist geordnet nach der Popularität der relationalen DBMS. Oracle, SQL Server und DB2 sind kommerzielle Systeme, MySQL, PostgreSQL, SQLite und MariaDB sind open source. MySQL wurde 2010 von Oracle aufgekauft und es hat sich ein zu MySQL kompatibler Fork MariaDB entwickelt. Alle hier dargestellten Systeme außer SQLite laufen als Serverprozess, sodass sich Anwendungen mit dem Datenbank-Server verbinden können, um Anfragen auf diesen zu stellen.</aside>
                        </section>
                        <section>
                            <h2>PostgreSQL</h2>
                            <ul style="width:18cm">
                                <li>&quot;The world's most advanced open source database&quot;</li>
                                <li>Einfach zu installieren, viele Features, Transaktionen, gute Dokumentation, ...</li>
                                <li>SQL-Clients: psql, pgAdmin3, pgAdmin4</li>
                            </ul>
                            <img src="img/4/postgres.png" class="noborder" style="position: absolute; width: 5cm; right: 1cm; top: 3cm">
                            <aside class="notes">psql ist ein Konsolen-Client, um z. B. in einer SSH-Shell direkt SQL-Befehle an eine PostgreSQL-Datenbank zu schicken und das Ergebnis zu betrachten. pgAdmin ist ein GUI-Client für verschiedene Betriebssysteme.</aside>
                        </section>
                        <section>
                            <h2>DBeaver</h2>
                            <p>Wir verwenden im Rahmen dieser Vorlesung den kostenlosen universellen SQL-Client DBeaver.</p>
                        </section>
                        
                        <section>
                                <h2>Sprachkomponenten</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 37</div>
                                <h4>DDL: Data Definition Language</h4>
                                <ul class="small">
                                    <li>Definition des Datenbankschemas (Metadaten)</li>
                                    <li><code>CREATE TABLE</code>, <code>DROP TABLE</code>, <code>ALTER TABLE</code>, <code>CREATE VIEW</code>, ...</li>
                                </ul>
                                <p/>
                                <h4 class="fragment" data-fragment-index="1">DML: Data Manipulation Language</h4>
                                <ul class="fragment small" data-fragment-index="1">
                                    <li>Einfügen, Ändern, Löschen und Lesen von Daten</li>
                                    <li><code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>SELECT</code>, ...</li>
                                </ul>
                                <p/>
                                <h4 class="fragment" data-fragment-index="2">DCL: Data Control Language</h4>
                                <ul class="fragment small" data-fragment-index="2">
                                    <li>Benutzer-, Rollen- und Rechteverwaltung</li>
                                    <li><code>CREATE USER</code>, <code>CREATE ROLE</code>, <code>GRANT</code>, <code>REVOKE</code>, ...</li>
                                </ul>
                                <aside class="notes">SELECT gehört zur DML, da die Daten für den Zeitpunkt der Anfragestellung manipuliert werden. Der Benutzer sieht eine modifizierte Form der Daten. Natürlich wird diese Änderung anders als z. B. bei UPDATE nicht persistent in der Datenbank gespeichert. </aside>
                            </section> 

                            <section>
                                <h2>SQL ausprobieren</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 38</div>
                                <h4>SQL Island</h4>
                                <img src="img/4/sql_island.png" class="noborder" style="position: absolute; width: 2.5cm; right: 1cm; top: 1mm">
                                <ul>
                                    <li>Lernspiel, welches keine Vorkenntnisse voraussetzt.</li>
                                    <li><a href="http://www.sql-island.de" target="_blank">sql-island.de</a></li>
                                </ul>
                                <p></p>
                                <h4>SQL Fiddle, DB Fiddle, Rextester</h4>
                                <ul>
                                    <li>Tabellen erstellen, befüllen und abfragen im Browser</li>
                                    <li><a href="http://sqlfiddle.com" target="_blank">sqlfiddle.com</a>, <a href="https://dbfiddle.uk" target="_blank">dbfiddle.uk</a>, <a href="http://rextester.com/" target="_blank">rextester.com</a></li>
                                    
                                </ul>
                                <aside class="notes">Alle hier dargestellten Anwendungen sind SQL-Spielwiesen, die ohne Anmeldung direkt im Browser verwendet werden können. Das Lernspiel SQL Island hat eine Handlung, man muss von einer Insel entkommen. Die Tabellen dazu sind bereits angelegt und mit Daten gefüllt. Bei den anderen Tools muss man selbst Tabellen anlegen und befüllen. Man hat verschiedene DBMS zur Auswahl.</aside>
                            </section>
                            <section>
                                <h2>Sprachelemente</h2>
                                <pre><code class="hlsql" data-trim contenteditable>SELECT email FROM kunden WHERE name = 'Ute';</code></pre>
                                <h4 style="font-size: 90%;">SQL-Schlüsselworte (Keywords)</h4>
                                <ul class="small">
                                    <li style="margin-top: -3mm;">Groß-/Kleinschreibung egal</li>
                                    <li>SELECT, FROM, WHERE, GROUP, BY, INSERT, CREATE, USER, AS, ...</li>
                                </ul>
                                
                                <h4 style="font-size: 90%; margin-top: 2mm;">Identifikatoren (Namen von Tabellen, Spalten, etc.)</h4>
                                <ul class="small">
                                    <li style="margin-top: -3mm;">Reguläre: case-insensitive; Begrenzte: case-sensitive</li>
                                    <li>Beispiele: email, kunden, name, "user", "Kunden", "A B"</li>
                                </ul>
                                
                                <h4 style="font-size: 90%; margin-top: 2mm;">Literale (Werte eines Datentyps)</h4>
                                <ul class="small">
                                    <li style="margin-top: -3mm;">Groß-/Kleinschreibung nicht egal!</li>
                                    <li>Beispiele: 'Ute', 'Otto''s Imbiss', 5, 2.99, NULL, '2019-11-18'</li>
                                </ul>

                                <aside class="notes">Merkregel: Bei allem, was man in Anführungszeichen schreibt, kommt es auf die korrekte Groß-/Kleinschreibung an. Bei regulären Identifikatoren sind reservierte SQL-Keywords und Sonderzeichen (außer _) verboten, bei begrenzten Identifikatoren ist dies erlaubt. In MySQL werden begrenzte Identifikatoren in `Apostrophe` geschrieben, bei PostgreSQL in &quot;Anführungszeichen&quot;.</aside>
                            </section>

                            <section>
                                <h2>Kommentare</h2>
                                <pre><code class="hlsql" data-trim contenteditable>SELECT * FROM t -- Ein Doppelminus leitet einen Kommentar ein</code></pre>

                                <pre><code class="hlsql" data-trim contenteditable>SELECT * FROM t
--WHERE x = 5</code></pre>

<pre><code class="hlsql" data-trim contenteditable>SELECT kundennummer /*, email*/ FROM kunden</code></pre>

                                 <aside class="notes">Alles, was in einer Zeile auf ein <code>--</code> folgt, ist ein Kommentar und gehört nicht mehr zur Anfrage. Dies ist auch praktisch, um vorübergehend gewisse Teile einer Anfrage wegzulassen und später wieder zu entkommentieren. Die Syntax <code>/* ... */</code> ermöglicht Kommentare innerhalb einer Zeile und Kommentare, die mehrere Zeilen umfassen.</aside>
                            </section>

                            <section>
                                <h2>DDL: CREATE, ALTER, DROP</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 44</div>
                                <p>Anlegen, Verändern und Entfernen von <em>Datenbankobjekten</em> (Tabellen, Sichten, Funktionen, ...)</p>
                                <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE personen (pid INT, name VARCHAR(500), geboren DATE);</code></pre>
                            
                                <h4>CREATE TABLE</h4>
                                <ul class="small">
                                    <li>Name der zu erstellenden Tabelle</li>
                                    <li>Spalten in Klammern, Komma-getrennt</li>
                                    <li>Zu jeder Spalte: Name, Datentyp, evtl. Spaltenoptionen</li>
                                </ul>

                                <aside class="notes">Das Semikolon am Ende einer Anfrage lassen wir ab sofort einfach weg. Es ist lediglich wichtig, wenn man in einem SQL-Editor mehrere Anfragen formuliert, um diese voneinander zu treffen.</aside>
                            </section>
                            <section>
                                <h2>Datentypen</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 39-41</div>
                                <table class="small">
                                    <thead><tr><th>Datentyp</th><th>Alias</th><th>Beschreibung</th><th>Beispiel</th></tr></thead>
                                    <tbody>
                                        <tr><td>INTEGER</td><td>INT</td><td>Ganze Zahl</td><td>-217</td></tr>
                                        <tr><td>DECIMAL(p,s)</td><td>NUMERIC</td><td>Zahl mit p Stellen, davon s nach dem Dezimalpunkt</td><td>DECIMAL(5,2) -149.99</td></tr>
                                        <tr><td>DOUBLE</td><td>REAL</td><td>Fließkommazahl (nicht exakt)</td><td>-15.127E-2</td></tr>
                                        <tr><td>CHARACTER(l)</td><td>CHAR</td><td>Zeichenkette mit fixer Länge l</td><td>CHAR(3) 'AB '</td></tr>
                                        <tr><td>CHARACTER VARYING(l)</td><td>VARCHAR</td><td>Zeichenkette mit max. Länge l</td><td>VARCHAR(3) 'AB'</td></tr>
                                        <tr><td>DATE</td><td></td><td>Datum (Jahr, Monat, Tag)</td><td>'2019-11-18'</td></tr>
                                        <tr><td>TIMESTAMP</td><td></td><td>Zeitstempel (Datum und Uhrzeit)</td><td>'2019-11-18 14:37:52.681'</td></tr>
                                    </tbody>
                                </table>
                                <aside class="notes">Diese Liste ist nicht vollständig. Es gibt noch viele weitere Datentypen in SQL und jedes DBMS bringt weitere Typen mit. Die hier dargestellte Fließkommazahl ist $-15$,$127\cdot 10^{-2}$.</aside>
                            </section>
                            <section>
                                <h3>CREATE TABLE - Spaltenoptionen</h3>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 45, 47</div>
                                <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE kunden (
 kundennummer INT PRIMARY KEY, name VARCHAR(100) NOT NULL, 
 email VARCHAR(500) CHECK (email LIKE '%@%') UNIQUE, 
 passwort CHAR(32), land VARCHAR(100) DEFAULT 'Deutschland', 
 geworben_von INT REFERENCES kunden(kundennummer));</code></pre>

                                <h4>Constraints (Integritätsbedingungen):</h4>
                                <ul class="small">
                                    <li>PRIMARY KEY: Primärschlüssel</li>
                                    <li>NOT NULL: Verbot von NULL-Werten</li>
                                    <li>CHECK: Bedingung für akzeptierte Werte</li>
                                    <li>UNIQUE: Eindeutigkeit</li>
                                    <li>DEFAULT: Standardwert</li>
                                    <li>REFERENCES: Fremdschlüsselreferenz</li>
                                </ul>
                                <aside class="notes">Hinter den Namen und Datentypen einer Spalte können Spaltenconstraints geschrieben werden. Dies sind Integritätsbedingungen, die stets erfüllt sein müssen. Beispielsweise verbietet ein UNIQUE-Constraint, dass in der Spalte in zwei Zeilen der gleiche Wert vorkommt. Das im Beispiel verwendete CHECK-Constraint garantiert, dass in jeder E-Mail-Adresse ein @-Zeichen vorkommen muss.</aside>
                            </section>

                            <section>
                                    <h3>NULL / NOT NULL</h3>
                                    <h4>NULL (Standard)</h4>
                                    <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE kunden (/* ... */, name VARCHAR(100) NULL)</code></pre>
                                    <p>NULL-Werte sind in der Spalte erlaubt.</p>
    
                                    <h4>NOT NULL</h4>
                                    <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE kunden (/* ... */, name VARCHAR(100) NOT NULL)</code></pre>
                                    <p>NULL-Werte sind in der Spalte verboten.</p>
                                    <aside class="notes">In den meisten DBMS ist <code>NULL</code> die Standard-Eigenschaft von Spalten, das heißt, man darf NULL-Werte in die Spalte eintragen. Will man dies verhindert, deklariert man die Spalte als <code>NOT NULL</code>. Im hier gezeigten unteren Beispiel ist das Attribut &quot;Name&quot; also ein Pflichtfeld.</aside>
                            </section>

                            <section>
                                <h3>UNIQUE-Constraint</h3>
                                <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE kunden (/* ... */, email VARCHAR(500) UNIQUE)</code></pre>
                                <p class="small">oder:</p>
                                <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE kunden (/* .... */ email VARCHAR(500), 
                     UNIQUE(email))</code></pre>
                                <aside class="notes">Spezifiziert man hinter einer Spalte die Eigenschaft <code>UNIQUE</code>, darf es in dieser Spalte keine doppelten Werte gegen. In unserer Kundentabelle dürfen also keine zwei Kunden die gleiche E-Mail-Adresse haben. Die untere Notation ist nötig, wenn das UNIQUE-Constraint aus mehreren Spalten besteht, also wenn die Kombination aus mehreren Spaltenwerten eindeutig sein soll.</aside>
                            </section>

                            <section>
                                <h3>Primärschlüssel-Constraint</h3>
                                <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE kunden (kundennummer INT PRIMARY KEY, ...)</code></pre>
                                <p class="small">oder:</p>
                                <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE kunden (kundennummer INT, ..., 
                     PRIMARY KEY(kundennummer))</code></pre>
                                
                            <p>Primärschlüssel sind UNIQUE und NOT NULL.</p>
                            <aside class="notes">Wenn der Primärschlüssel nur aus einer Spalte besteht, kann man <code>PRIMARY KEY</code> direkt hinter die Spalte schreiben. Primärschlüssel sind UNIQUE, d. h. es gibt keine Duplikate in der Tabelle in diesen Spalten. Außerdem sind Primärschlüsselattribute alle NOT NULL, d. h. in ihnen dürfen keine NULL-Werte vorkommen.</aside>
                                
                            </section>

                            <section>
                                <h3>Fremdschlüssel-Constraints</h3>
                                <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE kunden (/* ... */,
 geworben_von INT REFERENCES kunden(kundennummer));</code></pre>
                            <p class="small">oder:</p>
                            <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE kunden (/* ... */,
 geworben_von INT,
 FOREIGN KEY(geworben_von) REFERENCES kunden(kundennummer));</code></pre>
                            <aside class="notes">Besteht der Fremdschlüssel nur aus einer Spalte, kann <code>REFERENCES tabelle(spalte)</code> direkt hinter die Spalte geschrieben werden. Ansonsten muss die unten stehende <code>FOREIGN KEY</code>-Schreibweise verwendet werden.</aside>
                            </section>

                            <section>
                                <h3>Zusammengesetzte Primär-/Fremdschlüssel</h3>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 46, 48</div>
                                <pre><code class="hlsql" data-trim contenteditable data-line-numbers="6">CREATE TABLE bewertungen (
 kundennummer INT REFERENCES kunden(kundennummer),
 produktnummer INT REFERENCES produkte(produktnummer),
 sterne INT DEFAULT 5 CHECK(sterne BETWEEN 1 AND 5),
 bewertungstext VARCHAR(100000),
 PRIMARY KEY(kundennummer, produktnummer));</code></pre>
 <pre class="fragment"><code class="hlsql" data-trim contenteditable data-line-numbers="5-6">CREATE TABLE bewertungslikes (
 liker INT REFERENCES kunden(kundennummer),
 kundennummer INT, produktnummer INT,
 PRIMARY KEY(liker, kundennummer, produktnummer),
 FOREIGN KEY(kundennummer, produktnummer) 
  REFERENCES bewertungen(kundennummer, produktnummer));</code></pre>
                            <aside class="notes">Wenn der Primärschlüssel zusammengesetzt ist aus mehreren Spalten, ist es nicht mehr möglich, einfach PRIMARY KEY in die Spaltenoptionen zu schreiben. Stattdessen muss das PRIMARY-KEY-Constraint unten drunter geschrieben werden. Der Grund dafür ist, dass es nicht mehrere Primärschlüssel geben kann. Eine Tabelle hat immer nur einen Primärschlüssel, dieser kann jedoch zusammengesetzt sein aus mehreren Spalten. Das gleiche gilt für FOREIGN-KEY-Constraints für zusammengesetzte Fremdschlüssel.</aside>
                            </section>
                            
                            <section>
                                <h2>Referentielle Aktionen</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 49</div>
                                <pre><code class="hlsql" data-trim contenteditable data-line-numbers="5">CREATE TABLE produkte (
 produktnummer INT PRIMARY KEY, 
 bezeichnung VARCHAR(100) NOT NULL, preis DECIMAL(9,2), 
 hersteller VARCHAR(50) REFERENCES hersteller(firma) 
                        ON DELETE SET NULL ON UPDATE CASCADE);
                                </code></pre>
                                <p class="small">Was soll passieren, wenn ein Hersteller gelöscht wird, von dem es noch Produkte gibt? (Analog dazu: Was passiert, wenn man ihn umbenennt? - <code>ON UPDATE</code>)</p>
                                <ul class="small">
                                    <li class="fragment"><b><code>ON DELETE CASCADE</code></b>: Alle Produkte auch löschen</li>
                                    <li class="fragment"><b><code>ON DELETE SET NULL / SET DEFAULT</code></b>: NULL / Default-Wert setzen</li>
                                    <li class="fragment"><b><code>ON DELETE RESTRICT</code></b>: Löschen verbieten</li>
                                    <li class="fragment"><b><code>ON DELETE NO ACTION</code></b> (Standardverhalten): erst mal abwarten</li>
                                </ul>
                                <aside class="notes">Unter einer Aktion versteht man den Dann-Teil einer Wenn-Dann-Regel. Wenn man einen Hersteller löscht, dann... Im oben gezeigten Beispiel wird in einem solchen Fall wegen <code>ON DELETE SET NULL</code> der Wert der Hersteller-Spalte in der Produkte-Tabelle auf NULL gesetzt. Das <code>ON UPDATE CASCADE</code> sorgt dafür, dass bei einer Umbenennung im Primärschlüsselattribut des Herstellers (Firma) diese Umbenennung auch bei den Produkten dieses Herstellers erfolgt.</aside>
                            </section>
                            <section>
                                <h3>ON DELETE NO ACTION</h3>
                                <p class="small">Fachbereich (<u>FBName</u>)<br>
                                                 Studierende (<u>MatrNr</u>, Name, FBName)<br>
                                                 Professoren (<u>ProfNr</u>, Name, FBName)<br>
                                                 Prüfungen (<u>MatrNr, ProfNr, Fach, Versuch</u>, Note)</p>
                                <p class="small">&nbsp;</p>
                                <p class="small">Studierende(FBName) REFERENCES Fachbereich(FBName) ON DELETE CASCADE<br>
                                                 Professoren(FBName) REFERENCES Fachbereich(FBName) ON DELETE CASCADE<br>
                                                 Prüfungen(MatrNr) REFERENCES Studierende(MatrNr) ON DELETE CASCADE<br>
                                                 Prüfungen(ProfNr) REFERENCES Professoren(MatrNr)</p>

                                <p class="small">Fachbereich wird gelöscht &Rightarrow; alle Studierenden in diesem werden gelöscht &Rightarrow; Die Prüfungen der Studierenden werden gelöscht. Professoren werden gelöscht. OK!</p>

                                <div style="position:absolute; left: 560px; top: 80px; height: 240px; overflow:hidden;">
                                        <div class="erd" style="width: 450px;">
                                                [[
                                                { _e: "Fachbereich", pos: [130, 15] },
                                                { _e: "Studierender", pos: [5, 90] },
                                                { _e: "Professor", pos: [260, 90] },
                                                { _e: "Prüfung", pos: [130, 170], options:["weak"] },
                                                 
                                                ],
                                                [ {_r: "hat", _e:["Fachbereich", "Studierender"], card:["1","N"], pos: [40, 0]},
                                                  {_r: "hat", _e:["Fachbereich", "Professor"], card:["1","N"], pos: [300, 0]},
                                                  {_r: "legt ab", _e:["Studierender", "Prüfung"], card:["1","N"], pos: [40, 155]},
                                                  {_r: "prüft", _e:["Professor", "Prüfung"], card:["1","N"], pos: [300, 155]},
                                                ]]
                                        </div></div>
                                    <aside class="notes">Würde statt NO ACTION hier RESTRICT verwendet werden, kann es passieren, dass zuerst versucht wird, Professoren des Fachbereichs zu löschen. Dies wird jedoch abgelehnt, weil noch Prüfungen von diesem existieren. Würden zuerst die Studenten gelöscht, funktioniert das Löschen des Fachbereichs. Da das Verhalten in dem Fall nicht deterministisch ist, spricht man hier von einem <em>unsicheren Schema</em>.</aside>
                            </section>

                            <section>
                                <h3>DEFAULT-Werte für Spalten</h3>
                                <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE kunden (/* ... */,
                     land VARCHAR(100) DEFAULT 'Deutschland');</code></pre>
                                <p>Wird beim Einfügen in die Tabelle der Wert für eine Spalte nicht gesetzt, wird der DEFAULT-Wert dort eingetragen (standardmäßig NULL).</p>
                                <aside class="notes">Später beim <code>INSERT</code>-Kommando wird gezeigt, dass man nicht zwangsweise alle Spaltenwerte beim Einfügen einer neuen Zeile setzen muss. Die DEFAULT-Option legt für solche Fälle den Standardwert fest. Gibt es keinen definierten DEFAULT-Wert und wird der Wert nicht gesetzt, erhält die Zeile in der entsprechenden Spalte den Wert NULL. Ist auf der Spalte ein <code>NOT NULL</code>-Constraint definiert, kommt ein Fehler. Vor solchen Fehlern kann dann ein DEFAULT-Wert schützen. Wird mittels <code>ALTER TABLE ... ADD COLUMN</code> nachträglich eine neue Spalte mit DEFAULT-Wert einer existierenden Tabelle hinzugefügt, erhalten alle bisherigen Zeilen in der neuen Spalte diesen DEFAULT-Wert.</aside>
                            </section>

                            <section>
                                    <h3>Sequenzen / Autoincrement</h3>
                                    <p>Primärschlüsselwerte (z. B. IDs) automatisch erzeugen lassen.</p>
                                    <h4>In MySQL:</h4>
                                    <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE kunden(kundennr INT PRIMARY KEY AUTO_INCREMENT, ...);</code></pre>
                                    <h4>In PostgreSQL (aber auch MySQL):</h4>
                                    <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE kunden(kundennr SERIAL PRIMARY KEY  , ...);</code></pre>
                                    <aside class="notes">In verschiedenen DBMS gibt es die Spaltenoption <code>AUTO_INCREMENT</code> (MySQL), <code>AUTOINCREMENT</code> (SQLite), <code>GENERATED BY DEFAULT AS IDENTITY</code> (SQL Standard, Oracle, DB2), <code>IDENTITY</code> (Microsoft SQL Server), o. ä. Spalten mit dieser Option müssen einen nummerischen Datentypen haben. Eingefügte Zeilen erhalten standardmäßig eine automatisch generierte laufende Nummer. Problematisch kann es werden, wenn nan beim Einfügen auch selbst einen Wert setzt, statt ihn automatisch generieren zu lassen. Der SQL Standard und DB2 unterstützen <code>INTEGER GENERATED ALWAYS AS IDENTITY</code>, damit immer (nicht nur als Default) eine automatische ID erzeugt wird.</aside>
                                </section>

                            <section>
                                <h3>CHECK-Constraint</h3>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 47</div>
                                <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE kunden (/* ... */,
 email VARCHAR(500) CHECK (email LIKE '%@%'));</code></pre>
                     <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE bewertungen (/* ... */,
 sterne INT CHECK (sterne BETWEEN 1 AND 5));</code></pre>
                     <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE personen (/* ... */,
 geburtsdatum DATE,
 hochzeitsdatum DATE CHECK (hochzeitsdatum > geburtsdatum));</code></pre>
                            <aside class="notes">Mit einem CHECK-Constraint lassen sich benutzerdefinierte Spalten-Constraints definieren. In Klammern hinter dem Stichwort <code>CHECK</code> steht ein beliebiger boolescher Ausdruck, der stets wahr sein muss. Beim Einfügen und Ändern von Zeilen überprüft das DBMS die Bedingung und lehnt die entsprechende Operation ab, wenn das CHECK-Constraint verletzt würde. In den gezeigten Beispielen muss in der E-Mail-Spalte immer ein @-Zeichen vorkommen, der Wertebereich der Sterne-Spalte wird eingeschränkt auf ganze Zahlen zwischen 1 und 5, und das Hochzeitsdatum muss immer echt später sein als das Geburtsdatum einer Person.</aside>
                            </section>
                            
                            <section>
                                    <h2>CREATE TABLE LIKE / AS</h2>
                                    <div class="trackinfo"><i class="fas fa-headphones"></i> 51</div>
                                    <h4>CREATE TABLE</h4>
                                    <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE pkw (bez VARCHAR(50) PRIMARY KEY, leistung INT);</code></pre>

                                    <div class="fragment">
                                    <h4>CREATE TABLE LIKE</h4>
                                    <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE lkw LIKE pkw;</code></pre>
                                    </div>

                                    <div class="fragment">
                                    <h4>CREATE TABLE AS</h4>
                                    <pre><code class="hlsql" data-trim contenteditable>CREATE TABLE schrottkarren AS 
 SELECT * FROM pkw WHERE leistung < 60;</code></pre>
                                    </div>

                                    <aside class="notes">Alle drei hier gezeigten Befehle erstellen eine Tabelle. Bei der ersten gibt man die Spalten der Tabelle an, beim <code>CREATE TABLE LIKE</code> wird eine Tabelle mit den gleichen Spalten erstellt wie eine schon existierende Tabelle und <code>CREATE TABLE AS</code> speichert das Ergebnis einer SELECT-Anfrage in eine neu zu erstellende Tabelle. In den ersten beiden Kommandos ist die neue Tabelle leer, beim dritten Kommando können Daten in der neuen Tabelle sein. Mit <code>CREATE TABLE T2 AS SELECT * FROM T1</code> kann man eine Tabelle komplett mit Struktur und Daten kopieren.</aside>
                            </section>

                            

                            <section>
                                    <h2>ALTER / DROP</h2>
                                    <div class="trackinfo"><i class="fas fa-headphones"></i> 52</div>

                                    <p>ALTER: Verändern von Datenbankobjekten</p>
                                    <pre><code class="hlsql" data-trim contenteditable>ALTER TABLE bewertungen ADD COLUMN zeitstempel TIMESTAMP</code></pre>
    
                                    <p class="fragment" data-fragment-index="1">DROP: Entfernen von Datenbankobjekten</p>
                                    <pre class="fragment" data-fragment-index="1"><code class="hlsql" data-trim contenteditable>DROP TABLE bewertungen</code></pre>
                                    <aside class="notes">Die DDL-Befehle ALTER und DROP wirken sich genau wie CREATE auf den DB-Katalog aus. Das hier gezeigte ALTER TABLE ... ADD COLUMN-Kommando fügt eine neue Spalte namens &quot;zeitstempel&quot; vom Typ TIMESTAMP der Bewertungstabelle hinzu. Das gezeigte DROP-Kommando würde die Bewertungstabelle entfernen. Das heißt, es sind nicht nur alle Daten dieser Tabelle weg, sondern die ganze Tabelle existiert nicht mehr. Das DROP-Kommando hier würde aber abgelehnt werden, da es noch eine Tabelle Bewertungslikes gibt, bei der auf die Bewertungstabelle Fremdschlüsselreferenzen definiert sind. Man müsste also zunächst diese Tabelle oder zumindest die Fremdschlüssel droppen.</aside>
                            </section>

                            <section>
                                <h3>DML: INSERT, UPDATE, DELETE, ...</h3>
                                <p>Einfügen, ändern, löschen, abrufen von Daten.</p>
                                <pre><code class="hlsql" data-trim contenteditable>INSERT INTO produkte(produktnr, bezeichnung, preis, hersteller) 
             VALUES (88, 'Katzenfutter', 4.99, NULL)</code></pre>
                                <pre><code class="hlsql" data-trim contenteditable>UPDATE produkte SET preis = 5.99 WHERE produktnr = 88</code></pre>
                                <pre><code class="hlsql" data-trim contenteditable>DELETE FROM produkte WHERE produktnr = 88</code></pre>
                                <aside class="notes">Hier wird das Produkt Katzenfutter mit der Produktnummer 88 eingefügt, dann der Preis auf 5,99 EUR erhölt und im dritten Kommando wird die Zeile wieder gelöscht.</aside>
                            </section>

                            <section>
                                <h2>INSERT</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 53</div>
                                <pre><code class="hlsql" data-trim contenteditable>INSERT INTO produkte(produktnr, bezeichnung, preis, hersteller) 
             VALUES (88, 'Katzenfutter', 4.99, NULL)</code></pre>
                                
                                <div class="fragment">
                                <p class="small">Nur ein Teil der Spalten setzen:</p>
                                <pre><code class="hlsql" data-trim contenteditable>INSERT INTO produkte(preis, bezeichnung)
             VALUES (4.99, 'Katzenfutter')</code></pre>
                                </div>

                                <div class="fragment    ">
                                <p class="small">Spaltennamen weglassen:</p>
                                <pre><code class="hlsql" data-trim contenteditable>INSERT INTO produkte VALUES (88, 'Katzenfutter', 4.99, NULL)</code></pre>
                                </div>
                                <p class="fragment small">Nachteile: Schwerer verständlich zu lesen, man muss auf die korrekte Reihenfolge achten, man darf keine Spalte vergessen, in der Zukunft könnten sich die Spalten ändern.</p>
                                
                                <aside class="notes">Wenn nur ein Teil der Tabellenspalten gesetzt werden, werden die anderen Spalten auf ihre DEFAULT-Werte, den nächsten AUTO_INCREMENT / SERIAL-Wert oder auf NULL gesetzt. Lässt man die Spaltennamen vor dem Stichwort <code>VALUES</code> weg, müssen alle Spalten der Tabelle in der richtigen Reihenfolge gesetzt werden. Wenn in der Zukunft eine neue Spalte in die Produkttabelle hinzugefügt wird, würde das untere Kommando nicht mehr funktionieren.</aside>
                            </section>
                            
                            <section>
                                <h2>UPDATE</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 54</div>
                                <pre><code class="hlsql" data-trim contenteditable>UPDATE produkte SET preis = 5.99 WHERE produktnr = 88</code></pre>

                                <pre class="fragment"><code class="hlsql" data-trim contenteditable>UPDATE produkte 
SET preis = 5.99, bezeichnung = 'Spezial-Katzenfutter' 
WHERE produktnr = 88</code></pre>

                                <pre class="fragment"><code class="hlsql" data-trim contenteditable>UPDATE produkte SET preis = preis+1</code></pre>

                                <pre class="fragment"><code class="hlsql" data-trim contenteditable>UPDATE produkte SET preis = preis * 1.1</code></pre>
                                <aside class="notes">Das UPDATE-Kommando besteht aus einem SET-Teil und einem WHERE-Teil. Im SET werden Komma-getrennte Zuweisungen angegeben, um die neuen Spaltenwerte zu setzen. Der WHERE-Teil besteht aus einer Bedingung, die für eine Zeile erfüllt sein muss, damit diese entsprechend geändert wird. Lässt man die WHERE-Klausel weg, steht dies für <code>WHERE TRUE</code>, man ändert also alle Zeilen.</aside>
                            </section>
                            <section>
                                <h2>DELETE / TRUNCATE TABLE</h2>
                                <div class="trackinfo"><i class="fas fa-headphones"></i> 55</div>
                                <pre><code class="hlsql" data-trim contenteditable>DELETE FROM produkte WHERE produktnr = 88</code></pre>

                                <pre class="fragment"><code class="hlsql" data-trim contenteditable>DELETE FROM produkte</code></pre>

                                <pre class="fragment"><code class="hlsql" data-trim contenteditable>TRUNCATE TABLE produkte</code></pre>

                                <aside class="notes">Auch hier bestimmt die WHERE-Klausel wieder, welche Zeilen gelöscht werden sollen. Lässt man sie weg, löscht das System jede Zeile. Der TRUNCATE TABLE-Befehl ist jedoch meist schneller für solche Zwecke, er leert ebenfalls die komplette Tabelle.</aside>
                            </section>
                        </div>
                    </div>
            
                    <script src="reveal.js/js/reveal.js"></script>
                    <script src="lib/jquery.js"></script>
                    <script src="lib/lodash.js"></script>
                    <script src="lib/backbone.js"></script>
                    <script src="lib/joint.min.js"></script>
            
                    <script src="src/init_reveal.js"></script>
            
                    <script>
                    if(window.location.search.match( /print-pdf/gi )) {
                            document.getElementById('header').style="display:none";
                            document.getElementById('footer').style="display:none";
                    }
                    </script>
            
            
                </body>
            </html>
