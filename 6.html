<!doctype html>
<!--
    Database Preparation
    Schema + Data from http://sqlfiddle.com/#!17/11955/1
    !!! Change datatype of kunden.kundennummer to SERIAL !!!

    ALTER TABLE webshop.produkte RENAME COLUMN produktnummer TO produktnr;

    update kunden set passwort = md5('geheim');

    alter sequence webshop.kunden_kundennummer_seq restart with 9;
-->
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Datenbanken 1 - Kapitel 6 - Anwendungsentwicklung</title>

		<link rel="stylesheet" href="reveal.js/css/reset.css">
		<link rel="stylesheet" href="reveal.js/css/reveal.css">

        <link rel="stylesheet" href="src/slides.css">
        <link rel="stylesheet" href="src/sql.css">

		<link rel="stylesheet" href="src/layout.css">
        <link rel="stylesheet" href="lib/joint.min.css" />
        <link rel="stylesheet" href="src/erd.css" />

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="src/rainbow.css">

        <!--<script defer src="lib/fontawesome.all.min.js"/>-->
        <link href="lib/fontawesome.all.min.css" rel="stylesheet">
        <style> .reveal i.fa { font-family:FontAwesome; font-style: normal; } </style>



		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
            <div id="header"></div>
            <div id="footer"></div>
			<div class="slides">
                    <section>
                            <h4 style="text-align:center"><b>Dr.-Ing. Johannes Schildgen</b><br>
                            <a href="mailto:johannes.schildgen@h-da.de">johannes.schildgen@h-da.de</a></h4>
                            <h1>Datenbanken 1</h1>
                            <h3>Kapitel 6: Anwendungsentwicklung</h3>
                            <h4 style="text-align:center">2020-01-14</h4>
                            <img src="img/ccby.png" height="60px" style="position: absolute; left:0px; border:0; bottom:-160px;">
                            <img src="img/hda.png" height="60px" style="position: absolute; right:0px; border:0; bottom:-160px; box-shadow:none">
                        </section>
                        <section>
                          <h3>In diesem Kapitel erstellen wir...</h3>
                          <ul class="small">
                              <li>... Java-Anwendungen, die mit JDBC mit der Datenbank kommunizieren,</li>
                              <li>... Funktionen und Prozeduren direkt in der Datenbank,</li>
                              <li>... Trigger,</li>
                              <li>... Indexe.</li>
                          </ul>
                      </section> 
                      <section>
                          <h3>Anwendungsentwicklung</h3>
                          <div class="trackinfo"><i class="fas fa-headphones"></i> 99</div>
                            <ul class="small">
                                <li class="fragment">Lauffähige Anwendung in Java, C++, Python, PHP, ...</li>
                                <li class="fragment">Konsolenprogramm, GUI, App, Serverprozess, ...</li>
                                <li class="fragment">Komponenten:
                                    <ul>
                                        <li>Connection (Aufbau einer Verbindung zur DB)</li>
                                        <li class="fragment">Statement (Ausführung einer SQL-Anfrage)</li class="fragment">
                                        <li class="fragment">PreparedStatement (Statement mit Platzhaltern)</li class="fragment">
                                        <li class="fragment">ResultSet (Ergebnis einer ausgeführten Anfrage)</li class="fragment">
                                    </ul>
                                </li>
                            </ul>

                            <aside class="notes">Im ersten Teil dieses Kapitels betrachten wir Anwendungen, die nicht in der Datenbank laufen, sondern eigenständig sind. Sie stellen eine Verbindung zur Datenbank her, um an diese Anfragen zu schicken und die Ergebnisse dieser Anfragen zu verarbeiten.</aside>

                          <div class="sl-block" data-block-type="text" style="height: auto; width: 246px; left: 677px; top: 176.642px;" data-block-id="1953b372e575e378d1427477af8b1697">
                            <div class="sl-block-content" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 12; background-color:rgba(66, 169, 170, 0.99); border-style: solid; border-width: 1px; border-color: rgb(34, 34, 34);" data-fragment-index="0">
                                <p style="text-align:center; color:white">Anwendung</p>
                            </div>
                        </div>
                        
                        
                        <div class="sl-block" data-block-type="line" style="width: auto; height: auto; left: 799px; top: 229.642px;" data-block-id="672bf175b9e8a52980602cc2fc21f817">
                            <div class="sl-block-content" data-line-x1="181" data-line-y1="247" data-line-x2="180" data-line-y2="142" data-line-color="#000000" data-line-start-type="arrow" data-line-end-type="none" style="z-index: 13;" data-line-width="8px" data-fragment-index="0"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="1" height="105" viewBox="180 142 1 105">
                                    <line stroke="rgba(0,0,0,0)" stroke-width="15" x1="180.88571946838732" y1="235.00054418066827" x2="180" y2="142"></line>
                                    <line stroke="#000000" stroke-width="8" x1="180.88571946838732" y1="235.00054418066827" x2="180" y2="142"></line>
                                    <polygon fill="#000000" transform="translate(180.88571946838732,235.00054418066827) rotate(-0.546)" points="0,12 12,-12 -12,-12"></polygon>
                                </svg></div>
                        </div>
                        <div class="sl-block" data-block-type="shape" style="width: 245px; height: 59.5px; left: 678px; top: 351.642px;" data-block-id="c5318ebc130b3ee4af70f0e7f5a66b0b">
                            <div class="sl-block-content" data-shape-type="rect" data-shape-fill-color="rgb(111, 168, 220)" data-shape-stretch="true" style="z-index: 14;"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" preserveAspectRatio="none" viewBox="0 0 245 60">
                                    <rect width="245" height="59.5" rx="0" ry="0" class="shape-element" fill="rgb(111, 168, 220)"></rect>
                                </svg></div>
                        </div>
                        <div class="sl-block" data-block-type="shape" style="width: 245px; height: 45px; left: 678px; top: 328.642px;" data-block-id="10bb4dffa7d7c5d1c68a72c2ef8c8568">
                            <div class="sl-block-content" data-shape-type="circle" data-shape-fill-color="rgb(109, 158, 235)" data-shape-stretch="true" style="z-index: 15;" data-shape-stroke-color="#000000" data-shape-stroke-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" preserveAspectRatio="none" viewBox="0 0 245 45">
                                    <defs>
                                        <clipPath id="shape-mask-3-1577110259178">
                                            <ellipse rx="122.5" ry="22.5" cx="122.5" cy="22.5" fill="rgb(109, 158, 235)" stroke="#000000" stroke-width="10"></ellipse>
                                        </clipPath>
                                    </defs>
                                    <ellipse rx="122.5" ry="22.5" cx="122.5" cy="22.5" class="shape-element" fill="rgb(109, 158, 235)" stroke="#000000" stroke-width="10" clip-path="url(#shape-mask-3-1577110259178)"></ellipse>
                                </svg></div>
                        </div>
                        <div class="sl-block" data-block-type="shape" style="width: 245px; height: 45px; left: 678px; top: 388.642px;" data-block-id="fb8d8844b750525fc1a245f2849e3c7f">
                            <div class="sl-block-content" data-shape-type="circle" data-shape-fill-color="rgb(111, 168, 220)" data-shape-stretch="true" style="z-index: 11;" data-shape-stroke-color="#000000" data-shape-stroke-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" preserveAspectRatio="none" viewBox="0 0 245 45">
                                    <defs>
                                        <clipPath id="shape-mask-2-1577110259174">
                                            <ellipse rx="122.5" ry="22.5" cx="122.5" cy="22.5" fill="rgb(111, 168, 220)" stroke="#000000" stroke-width="10"></ellipse>
                                        </clipPath>
                                    </defs>
                                    <ellipse rx="122.5" ry="22.5" cx="122.5" cy="22.5" class="shape-element" fill="rgb(111, 168, 220)" stroke="#000000" stroke-width="10" clip-path="url(#shape-mask-2-1577110259174)"></ellipse>
                                </svg></div>
                        </div>
                        <div class="sl-block" data-block-type="line" style="width: auto; height: auto; left: 678px; top: 351.642px;" data-block-id="0942b832f1efe1703b62b47780b11474">
                            <div class="sl-block-content" data-line-x1="-30" data-line-y1="217" data-line-x2="-30" data-line-y2="158" data-line-color="#000000" data-line-start-type="none" data-line-end-type="none" style="z-index: 16;" data-line-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="1" height="59" viewBox="-30 158 1 59">
                                    <line stroke="rgba(0,0,0,0)" stroke-width="15" x1="-29.5" y1="217.5" x2="-29.5" y2="158.5"></line>
                                    <line stroke="#000000" stroke-width="5" x1="-29.5" y1="217.5" x2="-29.5" y2="158.5"></line>
                                </svg></div>
                        </div>
                        <div class="sl-block" data-block-type="line" style="width: auto; height: auto; left: 922px; top: 351.642px;" data-block-id="5287c637c5f2b0817dcaacb255726fe9">
                            <div class="sl-block-content" data-line-x1="-30" data-line-y1="217" data-line-x2="-30" data-line-y2="158" data-line-color="#000000" data-line-start-type="none" data-line-end-type="none" style="z-index: 17;" data-line-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="1" height="59" viewBox="-30 158 1 59">
                                    <line stroke="rgba(0,0,0,0)" stroke-width="15" x1="-29.5" y1="217.5" x2="-29.5" y2="158.5"></line>
                                    <line stroke="#000000" stroke-width="5" x1="-29.5" y1="217.5" x2="-29.5" y2="158.5"></line>
                                </svg></div>
                        </div>
                        <div class="sl-block" data-block-type="text" style="height: auto; width: 244px; left: 678px; top: 371.642px;" data-block-id="aa1aed179e2353e33c8a1878f6b5b433">
                            <div class="sl-block-content" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 18;">
                                <p style="text-align: center;">Datenbank</p>
                            </div>
                        </div>
                      </section>

                      <section>
                          <h2>Beispielanwendungen</h2>
                          <div class="columns">
                              <div>Konsolenprogramm
                                <img style="margin-top: -1.5cm;" src="img/6/console.png" class="noborder"></div>
                                <div class="fragment">GUI / App
                                <img src="img/6/todoapp.png" class="noborder">
                                <br/><br/><br/></div>
                          </div>
                          <aside class="notes">Das Python-Programm links stellt eine Verbindung mit einer Datenbank her, stellt eine SELECT-Anfrage und zeigt die Ergebnisse auf der Konsole an. Die Android-Anwendung rechts ist eine Todo-App (Bildquelle: Antonio Pardo, https://www.flickr.com/photos/apardo/3323321813). Diese Anwendung läuft lokal ohne Internetzugriff und speichert die Daten in eine SQLite-Datenbank, die auf dem Handy gespeichert ist.</aside>
                      </section>
                      <section>
                          <h2>Anwendungsserver</h2>
                          <p>Java EE, JSP, Java Servlets, .NET, PHP, Django, ...</p>
                          <p class="small">Endanwendung (z. B. Webbrowser) &rightarrow; Anwendungsserver &rightarrow; Datenbank</p>
                          <img src="img/6/webapp.png" class="noborder stretch">
                          <aside class="notes">Das hier gezeigte Tablet stellt keine direkte Verbindung zu einer Datenbank her, um die Daten für die Diagramme zu laden. Ansonsten könnte der Nutzer der App eventuell sogar die DB-Benutzerdaten auslesen. Stattdessen läuft auf einem Webserver eine Anwendung, welche mit der Datenbank interagiert und eine HTML-Seite erzeugt. Diese ruft der Browser des Tablets auf und zeigt sie an. Auch die Todo-App der vorherigen Folie könnte Server-basiert realisiert werden. In dem Fall reicht es, dass der Anwendungsserver die Daten als JSON oder XML bereitstellt, sodass die Smartphone-App diese dann entsprechend darstellen kann.</aside>
                      </section>

                      <section>
                          <h2>Embedded SQL</h2>
                          <p class="small">Ansatz: SQL-Anfragen und Programmcode mischen,<br>
                             dann erzeugt ein Precompiler das eigentliche lauffähige Programm.</p>

                        <p class="small">Beispiel: SQL Object-Language Bindings (OLB) für Java (vormals SQLJ)</p>
                        <pre><code class="hlsql dont_execute_sql" data-trim contenteditable>ProdukteIterator iter;
#sql iter = { SELECT bezeichnung, preis FROM produkte };
do {
  #sql { FETCH :iter INTO :bezeichnung, :preis };
  System.out.println(bezeichnung+" kostet "+preis+" EUR");
} while (!iter.endFetch());
iter.close();</code></pre>
<p class="fragment small">Vorteil: Syntaxüberprüfung der Anfrage und Prüfung auf gültige Tabellen- und Spaltennamen kann bereits bei der Compile-Zeit erfolgen.</p>
                <aside class="notes">Die Zeilen, die im Beispielcode mit #sql beginnen, werden vom Precompiler in Java-Code übersetzt. Gleichzeitig erfolgt eine Überprüfung, ob die Anfrage syntaktisch korrekt ist. Neben dem Java-Programm wird auch eine Profil-Datei erzeugt, die in die Datenbank gespeichert werden kann. Die Datenbank würde dabei einen Fehler liefern, wenn z. B. ein ungültiger Spaltenname verwendet wurde.</aside>      
                </section>
                <section>
                    <h2>JDBC</h2>
                    <p class="small">SQL-Anfragen werden API-Methoden als Strings übergeben.</p>
                    <pre><code class="hljava" data-sample='code/JDBC_Webshop/src/lecture/ZeigeProdukte.java#23-30' data-trim contenteditable>
                    </code></pre>
                    <p class="small">Vorteile: Flexibel (Anfragen können dynamisch zur Laufzeit generiert werden), kein Precompiler nötig, kompatibel mit allen Java-IDEs und vielen Frameworks.</p>
                    <aside class="notes">JDBC (Java Database Connectivity) ist eine universelle API-Schnittstelle für die Programmiersprache Java. </aside>
                </section> 

                <section>
                    <h2>Driver</h2>
                    <div class="columns">
                    <div>
                        <p class="small">Jedes DBMS hat seinen eigenen JDBC-Treiber: MySQL, PostgreSQL, Oracle, ...</p>
                        <p class="small">&Rightarrow; Entsprechende Jar herunterladen und dem Java-Projekt zur Verfügung stellen</p>
                    </div>
                    <div>
                        <img src="img/6/driver_jar.png" alt="Driver Jar" style="width:25cm">
                    </div>
                    </div>

                    <p class="small">Nun kann über die Klasse <code>DriverManager</code> eine Verbindung aufgebaut werden.</p>
                    
                    <aside class="notes">Bis Java 1.6 war es nötig, den Treiber mittels <code>Class.forName("org.postgresql.Driver");</code> zu laden. Mittlerweile unterstützen die meisten JDBC-Treiber den Java Service Provider-Mechanismus, sodass der Treiber automatisch geladen wird, den die JVM im Classpath findet.</aside>
                </section>

                <section>
                    <h2>Connection</h2>
                    <pre><code class="hljava" data-sample='code/JDBC_Webshop/src/lecture/ZeigeProdukte.java#9-16,21,20,33-37' data-sample-mark="4,7,12" data-trim contenteditable></code></pre>
                <aside class="notes">Eine JDBC-URL besteht aus <code>jdbc:</code>, dem Treiber-Namen, der Adresse des DB-Servers, dem Datenbanknamen und evtl. weiteren optionalen Properties. <code>DriverManager.getConnection</code> stellt eine Verbindung zur Datenbank her und liefert ein <code>Connection</code>-Objekt zurück. Mittels dieses Objekts kann nun mit der Datenbank gearbeitet werden. Tritt ein Fehler beim Verbinden auf (z. B. falsches Passwort), wird eine <code>SQLException</code> geworfen. Auch andere Methoden, z.&nbsp;B. diejenigen, die Anfragen an die Datenbank schicken, werfen im Fehlerfall ebendiese Exception. </aside>
                </section>

                <section>
                    <h2>Statement und ResultSet</h2>
                    <pre><code class="hljava" data-sample='code/JDBC_Webshop/src/lecture/ZeigeProdukte.java#22-31' data-sample-mark="" data-trim contenteditable></code></pre>
                
                <aside class="notes">Um eine Anfrage an die Datenbank zu schicken, kann auf der vorhandenen <code>Connection</code>ein <code>Statement</code>-Objekt erzeugt werden. Eine Anfrage wird mit der <code>executeQuery</code>- oder <code>executeUpdate</code>-Methode an die Datenbank geschickt. Erstere liefert ein <code>ResultSet</code> zurück, zweitere dient zur Ausführung von <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, usw. und liefert die Anzahl der betroffenen Zeilen zurück.<br>
                Über ein <code>ResultSet</code> kann mittels der <code>next()</code>-Methode iteriert werden. <code>next()</code> liefert <code>false</code>, wenn wir am Ende der Ergebnismenge angekommen sind. Wie im Beispiel gezeigt, kann man mit einer While-Schleife Zeile für Zeile über das Ergebnis einer ausgeführten Anfrage iterieren. In jeder Iteration stehen einem Datentyp-spezifische Methoden bereit, um auf die Spaltenwerte der aktuellen Zeile zuzugreifen; entweder über die Position (beginnend mit 1) oder über das Spaltenlabel: <code>rs.getString(1)</code> und <code>rs.getString("bezeichnung")</code> liefert beides den Wert der Ergebnisspalte &quot;bezeichnung&quot;.</aside>
                </section>

                <section>
                    <h2>SQL-Injections</h2>
                    <div class="trackinfo"><i class="fas fa-headphones"></i> 100</div>
                    <div style="position: absolute; top: 20px; right:5px; font-size:160px"><i class="fas fa-exclamation-triangle red"></i></div>
                    <p class="small">Vorsicht beim Erzeugen von Query-Strings,<br>die Benutzereingaben beinhalten! (&rightarrow; <a href="https://www.xkcd.com/327/" target="_blank">xkcd.com/327</a>)</p>
                    <pre><code class="java" data-trim contenteditable data-sample='code/JDBC_Webshop/src/lecture/ZeigeProdukt_SQLInjection.java#23-24'></code></pre>
                    <p class="fragment small"><em>Geben Sie einen Hersteller ein: </em><input type="text" value="'; DROP TABLE webshop.produkte;" style="font-size: 22pt; width:13cm"></p>
                    <p class="fragment"><input type="text" value="' UNION (SELECT email||' '||passwort, NULL FROM webshop.kunden)" style="font-size: 22pt; width:25cm"></p>
                    <aside class="notes">Mit SQL-Injections lassen sich Sicherheitslücken ausnutzen, die es dem Benutzer ermöglichen, Datenbankbefehle einzuschleusen. Das hier gezeigte Programm ist gut gemeint, aber unsicher. Wenn der Benutzer Hersteller Calgonte eingibt, soll <code>SELECT ... WHERE hersteller = 'Calgonte'</code> ausgeführt werden. Dadurch, dass der Benutzerinput ohne Überprüfung und Maskierung von Sonderzeichen einfach so als Teil der Anfrage an den String drangehangen wird, ermöglicht man dem Anwender beliebige Anfragen auf der Datenbank auszuführen. Ersterer Hack würde die Produkte-Tabelle droppen. Dies kann man mit der JDBC-Parameter-Einstellung <code>allowMultiQueries=false</code> verhindern. Der zweite Hack würde dennoch funktionieren. Er ermöglicht dem Angreifer die Einsicht der E-Mail-Adressen und Passwörter aller Kunden. Durch die Eingabe von <code>' OR 1=1 --</code> findet man alle Produkte.</aside>
                </section>

                <section>
                    <h2>SQL-Injections</h2>
                    <div class="trackinfo"><i class="fas fa-headphones"></i> 101</div>
                    <div style="position: absolute; top: 20px; right:5px; font-size:160px"><i class="fas fa-exclamation-triangle red"></i></div>
                    <p class="small">Anderes Beispiel: Login-Formular</p>
                    <table class="small" style="border: none; background-color: gainsboro;">
                        <tr><td style="border: none;">E-Mail:</td style="border: none;"><td style="border: none;"><input style="font-size: 20pt; width: 10cm" value="peter@example.com' --"></td style="border: none;"></tr>
                        <tr><td style="border: none;">Passwort:</td style="border: none;"><td style="border: none;"><input style="font-size: 20pt; width: 10cm" value=""></td style="border: none;"></tr>
                        <tr><td colspan="2"><input type="button" style="width:100%; font-size:200%; " value="Einloggen"></td></tr>
                    </table>
                    <pre><code class="java" data-trim contenteditable data-sample='code/JDBC_Webshop/src/lecture/Login_SQLInjection.java#26-28'></code></pre>
                    <aside class="notes">Dadurch dass der Hacker hier mit dem Anführungszeichen den String abschließt und mittels <code>--</code> den Rest der Anfrage auskommentiert, ergibt sich eine gültige Anfrage, welche lediglich überprüft, ob es den Benutzer gibt und nicht, ob das Passwort stimmt. Im Endeffekt wird ausgeführt: <code>SELECT COUNT(*) FROM webshop.kunden WHERE email = 'peter@example.com' -- AND passwort = md5('')</code>. Alles ab <code>--</code> wird ignoriert.
                    <br>Die md5-Funktion erzeugt einen Hash aus dem Passwort (z. B. d41d8cd98f00b204e9800998ecf8427e), welcher mit dem gespeicherten Hash verglichen wird. Dies verhindert das Abspeichern von Klartext-Passwörtern. Da md5 jedoch unsicher ist, sollte stattdessen eher sha256 verwendet werden.</aside>
                </section>

                <section>
                    <h2>PreparedStatement</h2>
                    <p class="small">Ein PreparedStatement beinhaltet <code>?</code>-Platzhalter, die vor der Ausführung der Anfrage mit ihren Werten belegt werden.</p>
                    <pre><code class="java" data-trim contenteditable data-sample='code/JDBC_Webshop/src/lecture/ZeigeProdukt.java#21-26'></code></pre>
                    <p class="small">Vorteile: Verhindert SQL SQL-Injections, weniger fehleranfällig, Wiederverwenden von Anfragen, Sonderzeichen (z. B. <code>'</code>) werden automatisch maskiert.</p>
                    <aside class="notes">Bevor ein PreparedStatement mittels <code>executeQuery</code> oder <code>executeUpdate</code> ausgeführt wird, muss jeder <code>?</code>-Platzhalter mit einem Wert belegt werden. Dazu werden Datentyp-spezifische Methoden eingesetzt, z. B. hier <code>setString</code>. Dadurch, dass in diesem gesetzten String Sonderzeichen wie <code>'</code> automatisch maskiert werden (z. B. zu <code>''</code>), sind keine SQL Injections mehr möglich. Ein und dasselbe PreparedStatement kann mehrfach wiederverwendet werden, was auch eine erhöhte Performance zur Folge haben kann. Ein weiterer Vorteil ist, dass man sich unschöne und fehleranfällige Anfrageelemente wie <code>WHERE hersteller = '"+scan.nextLine()+"'"</code> erspart. Hier vergisst man gerne mal ein <code>'</code>.</aside>
                </section>

                <section>
                    <h2>executeUpdate</h2>
                    <pre><code class="java" data-trim contenteditable data-sample='code/JDBC_Webshop/src/lecture/NeuerKunde.java#17-27' data-sample-mark=""></code></pre>
                    <aside class="notes">Anders als <code>executeQuery</code> liefert <code>executeUpdate</code> kein ResultSet zurück, sondern einen Integer: die Anzahl der betroffenen Zeilen. Beim hier gezeigten INSERT ist dies stets eine 1, da nur eine Zeile eingefügt wird. Im Fehlerfall wird eine Exception geworfen. Bei einem UPDATE- oder DELETE-Kommando kann man am Rückgabewert der Methode sehen, wie viele Zeilen geändert oder gelöscht wurden. Neben <code>executeUpdate</code> und <code>executeQuery</code> gibt es auch noch die Methode <code>execute</code>. Diese liefert keinen Rückgabewert. Man verwendet sie z. B. für <code>CREATE TABLE</code> oder andere DDL-Kommandos.</aside>
                </section>

                <section>
                    <h3>DB-Metadaten-Zugriff mit JDBC</h3>
                    <h4>DatabaseMetaData</h4>
                    <pre><code class="java" data-trim contenteditable data-sample='code/JDBC_Webshop/src/lecture/MetadataExample.java#16-21' data-sample-mark=""></code></pre>
                    <h4>ResultSetMetaData</h4>
                    <pre><code class="java" data-trim contenteditable data-sample='code/JDBC_Webshop/src/lecture/MetadataExample.java#27-33' data-sample-mark=""></code></pre>
                    <aside class="notes">JDBC stellt Methoden bereit, um auf die Metadaten der Datenbank (z. B. Tabellen, Spalten einer Tabelle, ...) und auf Metadaten eines ResultSets zuzugreifen.</aside>
                </section>

                <section>
                    <h2>Routinen</h2>
                    <p>Benutzerdefinierte Routinen sind in der DB gespeicherte Datenbankobjekte (wie Tabellen und Views):</p>
                    <ul>
                        <li><b>Prozeduren</b> tun etwas</li>
                        <li><b>Funktionen (UDF)</b> liefern einen Ergebniswert</li>
                        <li><b>Tabellenfunktionen</b> liefern eine Tabelle</li>
                        <li><b>Methoden</b> gehören zu einem User-defined Datatype</li>
                    </ul>
                    <p>Routen haben einen Namen und Eingabeparameter.</p>
                    <aside class="notes">Die meisten Datenbankmanagementsysteme erlauben die Erstellung von Routinen in einer Programmiersprache. In PostgreSQL heißt diese Sprache PL/pgSQL (Prozedurale Spracherweiterung für PostgreSQL). Neben SQL-Anfragen (SELECT, INSERT, ...) gibt es auch IF-Blöcke, FOR-Schleifen, usw. Methoden werden in dieser Vorlesung nicht behandelt.</aside>
                </section>

                <section>
                    <h2>PG/plSQL</h2>
                    <h4>Block:</h4>
                    <pre><code class="hlsql dont_execute_sql" data-trim contenteditable>
                        [ DECLARE 
                        -- hier können Variablen definiert werden ]
                        BEGIN
                        -- Anweisungen ...
                        END
                    </code></pre>
                    <h4>Kontrollstrukturen:</h4>
                        <pre><code class="hlsql dont_execute_sql" data-trim contenteditable>
                            IF ... THEN ... [ELSE ...] END;
                            WHILE ... LOOP ... END LOOP;
                            LOOP ... EXIT WHEN ...; END LOOP;
                            FOR ... IN ... .. ... LOOP ... END LOOP;
                            FOR ... IN 'SELECT ...' LOOP ... END LOOP;
                        </code></pre>
                </section>

                <section>
                    <h2>Stored Procedures</h2>
                    <pre><code class="hlsql dont_execute_sql" data-trim contenteditable>
CREATE OR REPLACE FUNCTION alles_leeren() RETURNS void AS
$$ BEGIN
 TRUNCATE bewertungen CASCADE;
 TRUNCATE produkte CASCADE;
 TRUNCATE hersteller CASCADE;
 TRUNCATE kunden CASCADE;
END $$ LANGUAGE plpgsql;</code></pre>

<pre><code class="hlsql dont_execute_sql" contenteditable>SELECT alles_leeren();</code></pre>

                <aside class="notes">In diesem einfachen Beispiel hat unsere Prozedur <code>alles_leeren</code> keine Eingabeparameter (daher die leeren Klammern <code>()</code>), wir definieren keine Variablen und verwenden auch keine Kontrollstrukturen oder Schleifen. Es werden lediglich vier <code>TRUNCATE</code>-Kommandos ausgeführt. In PostgreSQL sind Prozeduren <code>FUNCTION</code>-Objekte mit dem Rückgabetyp <code>void</code>. Man ruft sie in einem <code>SELECT</code>-Kommando ohne <code>FROM</code>-Klausel auf. Seit PostgreSQL 11 gibt es jedoch auch <code>CREATE PROCEDURE</code>, welche dann mit einem <code>CALL</code>-Befehl aufgerufen werden (siehe übernächste Folie). In anderen DBMS werden Prozeduren mit einem <code>EXECUTE</code>-Befehl ausgeführt.<br>Schreibt man <code>CREATE OR REPLACE</code> statt einfach nur <code>CREATE</code>, wird die Funktion überschrieben, falls sie schon existiert.</aside>
                </section>
            <section>
                <h3>RAISE NOTICE</h3>
                <p class="small"><code>RAISE NOTICE</code> gibt einen Infotext auf der Konsole aus.</p>
                <pre><code class="hlsql dont_execute_sql" data-trim contenteditable>
CREATE OR REPLACE FUNCTION hallo() RETURNS void AS $$
DECLARE
    x INT := 5;
BEGIN
    RAISE NOTICE 'Hallo!!!';
    RAISE NOTICE 'x ist %', x;
END $$ LANGUAGE plpgsql;</code></pre>

<pre><code class="hlsql dont_execute_sql" contenteditable>SELECT hallo();</code></pre>
            <img src="img/6/dbeaver_notice.png" alt="DBeaver Serverausgabe anzeigen" style="width:12cm">
            <aside class="notes">Verwendet man im Notice %-Platzhalter, kann man deren Werte als zusätzliche Parameter übermitteln. Diese Folie zeigt auch, wie man Variablen deklariert. Bei <code>x INT := 5;</code> hat x den Wert 5. Mit <code>x INT</code> würde man lediglich die Variable x ohne Wert definieren, damit man diesen später zuweisen kann.</aside>
            </section>

            <section>
                <h2>Stored Procedures</h2>
                <pre><code class="hlsql dont_execute_sql" data-trim contenteditable>
CREATE PROCEDURE bestelle_produkt(_kundennr INT, 
                                  _produktnr INT) AS $$
DECLARE
   _bestellnr INT;
BEGIN
  SELECT MAX(bestellnummer)+1 INTO _bestellnr FROM bestellungen;
  RAISE NOTICE 'Bestellnummer: %', _bestellnr;
  INSERT INTO bestellungen(bestellnummer, kundennummer, zeit, 
    preis) VALUES (_bestellnr, _kundennr, current_timestamp,
    (SELECT preis FROM produkte WHERE produktnr=_produktnr));
  INSERT INTO bestellungen_positionen (bestellnummer, 
    produktnummer, anzahl) VALUES (_bestellnr, _produktnr, 1);
  COMMIT;
END $$ LANGUAGE plpgsql;</code></pre>

<pre><code class="hlsql dont_execute_sql" data-trim contenteditable>CALL bestelle_produkt(5, 17);</code></pre>
                    
            <aside class="notes">Anders als bei <code>CREATE FUNCTION</code> werden bei PostgreSQL im <code>CREATE PROCEDURE</code> auch Transaktionen (<code>COMMIT</code> / <code>ROLLBACK</code>) unterstützt. Damit wird garantiert, dass beide hier dargestellten <code>INSERT</code>s ausgeführt werden (oder keines) und dass die mit MAX ermittelte neue Bestellnummer auch in jedem Fall gültig ist, auch wenn andere Transaktionen parallel Bestellungen einfügen (&rightarrow; Phantomproblem).</aside>
            </section>
            
            <section>
                <h3>Eingabeparameter</h3>
                <p class="small">Zugriff über den Namen oder die Position (<code>$1</code>, ...)</p>

<pre><code class="hlsql dont_execute_sql" data-trim contenteditable>CREATE OR REPLACE PROCEDURE test(i int, s VARCHAR) AS $$
BEGIN
 RAISE NOTICE 'i ist %', i;     -- i ist 99
 RAISE NOTICE 's ist %', $2;    -- s ist Tomate
END $$ LANGUAGE plpgsql;</code></pre>

<pre><code class="hlsql dont_execute_sql" contenteditable>CALL test(99, 'Tomate');</code></pre>
<aside class="notes"><code>$2</code> steht hier für den zweiten Parameter, also für <code>s</code>. Wir verwenden in den Beispielen aber auch oft Variablennamen, die mit einem Unterstrich beginnen (z. B. <code>_produktnr</code>), damit man sie nicht mit Spaltennamen oder ähnlichem verwechselt.</aside>
</section>

<section>
    <h2>Funktionen</h2>
    <p>UDF = User-defined Function</p>

    <pre><code class="hlsql dont_execute_sql" contenteditable>CREATE OR REPLACE FUNCTION addieren(int, int) RETURNS INT AS
$$ BEGIN RETURN $1+$2; END $$ LANGUAGE plpgsql;</code></pre>

    <pre><code class="hlsql dont_execute_sql" contenteditable>SELECT addieren(5,4);</code></pre>

    <pre class="fragment"><code class="hlsql dont_execute_sql" contenteditable>SELECT *, addieren(sterne, 1) FROM bewertungen;</code></pre>

    <aside class="notes">Funktionen haben beliebig viele Eingabeparameter und liefern genau einen Rückgabewert zurück. Der Datentyp des Rückgabewerts steht oben hinter <code>RETURNS</code>. Mit einem <code>RETURN</code>-Kommando terminiert die Funktion und erzeugt die Rückgabe. Man kann die Funktion genau wie eingebaute SQL-Funktionen (UPPER, MD5, ...) in SELECT-Anfragen mit und ohne FROM-Klausel verwenden, aber auch in INSERT, UPDATE, etc. Die hier dargestellte Funktion addiert zwei Zahlen. Die Eingabeparameternamen kann man wie hier gezeigt einfach weggelassen, wenn man auf sie lediglich mittels <code>$1</code> etc. zugreift.</aside>
</section>

<section>
    <h2>Tabellenfunktionen</h2>
    <pre><code class="hlsql dont_execute_sql" contenteditable>CREATE OR REPLACE FUNCTION produkte_von(VARCHAR) RETURNS TABLE
(produktnr INT, bezeichnung VARCHAR(100), 
 preis DECIMAL(9,2), hersteller VARCHAR(50)) AS $$ 
SELECT produktnr, bezeichnung, preis, hersteller 
FROM produkte WHERE hersteller = $1 
$$ LANGUAGE sql;
</code></pre>
        
            <pre><code class="hlsql dont_execute_sql" contenteditable>SELECT * FROM produkte_von('Calgonte');</code></pre>
        
        <aside class="notes">Tabellenfunktionen liefert eine Tabelle zurück mit beliebig vielen Zeilen. Die Spalten und deren Typen werden im <code>CREATE FUNCTION</code>-Kommando im <code>RETURNS TABLE</code>-Teil definiert. Genau wie eine View wird eine Tabellenfunktion in der <code>FROM</code>-Klausel einer SELECT-Anfrage aufgerufen. Eine Tabellenfunktion ist quasi eine View mit Parametern.</aside>
</section>

                        </div>
                    </div>
            
                    <script src="reveal.js/js/reveal.js"></script>
                    <script src="lib/jquery.js"></script>
                    <script src="lib/lodash.js"></script>
                    <script src="lib/backbone.js"></script>
                    <script src="lib/joint.min.js"></script>
            
                    <script src="src/init_reveal.js"></script>
            
                    <script>
                    if(window.location.search.match( /print-pdf/gi )) {
                            document.getElementById('header').style="display:none";
                            document.getElementById('footer').style="display:none";
                    }
                    </script>
            
            
                </body>
            </html>
