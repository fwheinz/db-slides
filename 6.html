<!doctype html>
<!--
    Database Preparation
    Schema + Data from http://sqlfiddle.com/#!17/11955/1
    !!! Change datatype of kunden.kundennummer to SERIAL !!!

    ALTER TABLE webshop.produkte RENAME COLUMN produktnummer TO produktnr;

    update kunden set passwort = md5('geheim');

    alter sequence webshop.kunden_kundennummer_seq restart with 9;
-->
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Datenbanken 1 - Kapitel 6 - Anwendungsentwicklung</title>

		<link rel="stylesheet" href="reveal.js/css/reset.css">
		<link rel="stylesheet" href="reveal.js/css/reveal.css">

        <link rel="stylesheet" href="src/slides.css">
        <link rel="stylesheet" href="src/sql.css">

		<link rel="stylesheet" href="src/layout.css">
        <link rel="stylesheet" href="lib/joint.min.css" />
        <link rel="stylesheet" href="src/erd.css" />

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="src/rainbow.css">

        <!--<script defer src="lib/fontawesome.all.min.js"/>-->
        <link href="lib/fontawesome.all.min.css" rel="stylesheet">
        <style> .reveal i.fa { font-family:FontAwesome; font-style: normal; } </style>



		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
            <div id="header"></div>
            <div id="footer"></div>
			<div class="slides">
                    <section>
                            <h4 style="text-align:center"><b>Dr.-Ing. Johannes Schildgen</b><br>
                            <a href="mailto:johannes.schildgen@h-da.de">johannes.schildgen@h-da.de</a></h4>
                            <h1>Datenbanken 1</h1>
                            <h3>Kapitel 6: Anwendungsentwicklung</h3>
                            <h4 style="text-align:center">2020-01-14</h4>
                            <img src="img/ccby.png" height="60px" style="position: absolute; left:0px; border:0; bottom:-160px;">
                            <img src="img/hda.png" height="60px" style="position: absolute; right:0px; border:0; bottom:-160px; box-shadow:none">
                        </section>
                        <section>
                          <h3>In diesem Kapitel erstellen wir...</h3>
                          <ul class="small">
                              <li>... Java-Anwendungen, die mit JDBC mit der Datenbank kommunizieren,</li>
                              <li>... Funktionen und Prozeduren direkt in der Datenbank,</li>
                              <li>... Trigger,</li>
                              <li>... Indexe.</li>
                          </ul>
                      </section> 
                      <section>
                          <h3>Anwendungsentwicklung</h3>
                          <div class="trackinfo"><i class="fas fa-headphones"></i> 99</div>
                            <ul class="small">
                                <li class="fragment">Lauffähige Anwendung in Java, C++, Python, PHP, ...</li>
                                <li class="fragment">Konsolenprogramm, GUI, App, Serverprozess, ...</li>
                                <li class="fragment">Komponenten:
                                    <ul>
                                        <li>Connection (Aufbau einer Verbindung zur DB)</li>
                                        <li class="fragment">Statement (Ausführung einer SQL-Anfrage)</li class="fragment">
                                        <li class="fragment">PreparedStatement (Statement mit Platzhaltern)</li class="fragment">
                                        <li class="fragment">ResultSet (Ergebnis einer ausgeführten Anfrage)</li class="fragment">
                                    </ul>
                                </li>
                            </ul>

                            <aside class="notes">Im ersten Teil dieses Kapitels betrachten wir Anwendungen, die nicht in der Datenbank laufen, sondern eigenständig sind. Sie stellen eine Verbindung zur Datenbank her, um an diese Anfragen zu schicken und die Ergebnisse dieser Anfragen zu verarbeiten.</aside>

                          <div class="sl-block" data-block-type="text" style="height: auto; width: 246px; left: 677px; top: 176.642px;" data-block-id="1953b372e575e378d1427477af8b1697">
                            <div class="sl-block-content" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 12; background-color:rgba(66, 169, 170, 0.99); border-style: solid; border-width: 1px; border-color: rgb(34, 34, 34);" data-fragment-index="0">
                                <p style="text-align:center; color:white">Anwendung</p>
                            </div>
                        </div>
                        
                        
                        <div class="sl-block" data-block-type="line" style="width: auto; height: auto; left: 799px; top: 229.642px;" data-block-id="672bf175b9e8a52980602cc2fc21f817">
                            <div class="sl-block-content" data-line-x1="181" data-line-y1="247" data-line-x2="180" data-line-y2="142" data-line-color="#000000" data-line-start-type="arrow" data-line-end-type="none" style="z-index: 13;" data-line-width="8px" data-fragment-index="0"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="1" height="105" viewBox="180 142 1 105">
                                    <line stroke="rgba(0,0,0,0)" stroke-width="15" x1="180.88571946838732" y1="235.00054418066827" x2="180" y2="142"></line>
                                    <line stroke="#000000" stroke-width="8" x1="180.88571946838732" y1="235.00054418066827" x2="180" y2="142"></line>
                                    <polygon fill="#000000" transform="translate(180.88571946838732,235.00054418066827) rotate(-0.546)" points="0,12 12,-12 -12,-12"></polygon>
                                </svg></div>
                        </div>
                        <div class="sl-block" data-block-type="shape" style="width: 245px; height: 59.5px; left: 678px; top: 351.642px;" data-block-id="c5318ebc130b3ee4af70f0e7f5a66b0b">
                            <div class="sl-block-content" data-shape-type="rect" data-shape-fill-color="rgb(111, 168, 220)" data-shape-stretch="true" style="z-index: 14;"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" preserveAspectRatio="none" viewBox="0 0 245 60">
                                    <rect width="245" height="59.5" rx="0" ry="0" class="shape-element" fill="rgb(111, 168, 220)"></rect>
                                </svg></div>
                        </div>
                        <div class="sl-block" data-block-type="shape" style="width: 245px; height: 45px; left: 678px; top: 328.642px;" data-block-id="10bb4dffa7d7c5d1c68a72c2ef8c8568">
                            <div class="sl-block-content" data-shape-type="circle" data-shape-fill-color="rgb(109, 158, 235)" data-shape-stretch="true" style="z-index: 15;" data-shape-stroke-color="#000000" data-shape-stroke-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" preserveAspectRatio="none" viewBox="0 0 245 45">
                                    <defs>
                                        <clipPath id="shape-mask-3-1577110259178">
                                            <ellipse rx="122.5" ry="22.5" cx="122.5" cy="22.5" fill="rgb(109, 158, 235)" stroke="#000000" stroke-width="10"></ellipse>
                                        </clipPath>
                                    </defs>
                                    <ellipse rx="122.5" ry="22.5" cx="122.5" cy="22.5" class="shape-element" fill="rgb(109, 158, 235)" stroke="#000000" stroke-width="10" clip-path="url(#shape-mask-3-1577110259178)"></ellipse>
                                </svg></div>
                        </div>
                        <div class="sl-block" data-block-type="shape" style="width: 245px; height: 45px; left: 678px; top: 388.642px;" data-block-id="fb8d8844b750525fc1a245f2849e3c7f">
                            <div class="sl-block-content" data-shape-type="circle" data-shape-fill-color="rgb(111, 168, 220)" data-shape-stretch="true" style="z-index: 11;" data-shape-stroke-color="#000000" data-shape-stroke-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="100%" height="100%" preserveAspectRatio="none" viewBox="0 0 245 45">
                                    <defs>
                                        <clipPath id="shape-mask-2-1577110259174">
                                            <ellipse rx="122.5" ry="22.5" cx="122.5" cy="22.5" fill="rgb(111, 168, 220)" stroke="#000000" stroke-width="10"></ellipse>
                                        </clipPath>
                                    </defs>
                                    <ellipse rx="122.5" ry="22.5" cx="122.5" cy="22.5" class="shape-element" fill="rgb(111, 168, 220)" stroke="#000000" stroke-width="10" clip-path="url(#shape-mask-2-1577110259174)"></ellipse>
                                </svg></div>
                        </div>
                        <div class="sl-block" data-block-type="line" style="width: auto; height: auto; left: 678px; top: 351.642px;" data-block-id="0942b832f1efe1703b62b47780b11474">
                            <div class="sl-block-content" data-line-x1="-30" data-line-y1="217" data-line-x2="-30" data-line-y2="158" data-line-color="#000000" data-line-start-type="none" data-line-end-type="none" style="z-index: 16;" data-line-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="1" height="59" viewBox="-30 158 1 59">
                                    <line stroke="rgba(0,0,0,0)" stroke-width="15" x1="-29.5" y1="217.5" x2="-29.5" y2="158.5"></line>
                                    <line stroke="#000000" stroke-width="5" x1="-29.5" y1="217.5" x2="-29.5" y2="158.5"></line>
                                </svg></div>
                        </div>
                        <div class="sl-block" data-block-type="line" style="width: auto; height: auto; left: 922px; top: 351.642px;" data-block-id="5287c637c5f2b0817dcaacb255726fe9">
                            <div class="sl-block-content" data-line-x1="-30" data-line-y1="217" data-line-x2="-30" data-line-y2="158" data-line-color="#000000" data-line-start-type="none" data-line-end-type="none" style="z-index: 17;" data-line-width="5px"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" preserveAspectRatio="xMidYMid" width="1" height="59" viewBox="-30 158 1 59">
                                    <line stroke="rgba(0,0,0,0)" stroke-width="15" x1="-29.5" y1="217.5" x2="-29.5" y2="158.5"></line>
                                    <line stroke="#000000" stroke-width="5" x1="-29.5" y1="217.5" x2="-29.5" y2="158.5"></line>
                                </svg></div>
                        </div>
                        <div class="sl-block" data-block-type="text" style="height: auto; width: 244px; left: 678px; top: 371.642px;" data-block-id="aa1aed179e2353e33c8a1878f6b5b433">
                            <div class="sl-block-content" data-placeholder-tag="p" data-placeholder-text="Text" style="z-index: 18;">
                                <p style="text-align: center;">Datenbank</p>
                            </div>
                        </div>
                      </section>

                      <section>
                          <h2>Beispielanwendungen</h2>
                          <div class="columns">
                              <div>Konsolenprogramm
                                <img style="margin-top: -1.5cm;" src="img/6/console.png" class="noborder"></div>
                                <div class="fragment">GUI / App
                                <img src="img/6/todoapp.png" class="noborder">
                                <br/><br/><br/></div>
                          </div>
                          <aside class="notes">Das Python-Programm links stellt eine Verbindung mit einer Datenbank her, stellt eine SELECT-Anfrage und zeigt die Ergebnisse auf der Konsole an. Die Android-Anwendung rechts ist eine Todo-App (Bildquelle: Antonio Pardo, https://www.flickr.com/photos/apardo/3323321813). Diese Anwendung läuft lokal ohne Internetzugriff und speichert die Daten in eine SQLite-Datenbank, die auf dem Handy gespeichert ist.</aside>
                      </section>
                      <section>
                          <h2>Anwendungsserver</h2>
                          <p>Java EE, JSP, Java Servlets, .NET, PHP, Django, ...</p>
                          <p class="small">Endanwendung (z. B. Webbrowser) &rightarrow; Anwendungsserver &rightarrow; Datenbank</p>
                          <img src="img/6/webapp.png" class="noborder stretch">
                          <aside class="notes">Das hier gezeigte Tablet stellt keine direkte Verbindung zu einer Datenbank her, um die Daten für die Diagramme zu laden. Ansonsten könnte der Nutzer der App eventuell sogar die DB-Benutzerdaten auslesen. Stattdessen läuft auf einem Webserver eine Anwendung, welche mit der Datenbank interagiert und eine HTML-Seite erzeugt. Diese ruft der Browser des Tablets auf und zeigt sie an. Auch die Todo-App der vorherigen Folie könnte Server-basiert realisiert werden. In dem Fall reicht es, dass der Anwendungsserver die Daten als JSON oder XML bereitstellt, sodass die Smartphone-App diese dann entsprechend darstellen kann.</aside>
                      </section>

                      <section>
                          <h2>Embedded SQL</h2>
                          <p class="small">Ansatz: SQL-Anfragen und Programmcode mischen,<br>
                             dann erzeugt ein Precompiler das eigentliche lauffähige Programm.</p>

                        <p class="small">Beispiel: SQL Object-Language Bindings (OLB) für Java (vormals SQLJ)</p>
                        <pre><code class="hlsql dont_execute_sql" data-trim contenteditable>ProdukteIterator iter;
#sql iter = { SELECT bezeichnung, preis FROM produkte };
do {
  #sql { FETCH :iter INTO :bezeichnung, :preis };
  System.out.println(bezeichnung+" kostet "+preis+" EUR");
} while (!iter.endFetch());
iter.close();</code></pre>
<p class="fragment small">Vorteil: Syntaxüberprüfung der Anfrage und Prüfung auf gültige Tabellen- und Spaltennamen kann bereits bei der Compile-Zeit erfolgen.</p>
                <aside class="notes">Die Zeilen, die im Beispielcode mit #sql beginnen, werden vom Precompiler in Java-Code übersetzt. Gleichzeitig erfolgt eine Überprüfung, ob die Anfrage syntaktisch korrekt ist. Neben dem Java-Programm wird auch eine Profil-Datei erzeugt, die in die Datenbank gespeichert werden kann. Die Datenbank würde dabei einen Fehler liefern, wenn z. B. ein ungültiger Spaltenname verwendet wurde.</aside>      
                </section>
                <section>
                    <h2>JDBC</h2>
                    <p class="small">SQL-Anfragen werden API-Methoden als Strings übergeben.</p>
                    <pre><code class="hljava" data-sample='code/JDBC_Webshop/src/lecture/ZeigeProdukte.java#23-30' data-trim contenteditable>
                    </code></pre>
                    <p class="small">Vorteile: Flexibel (Anfragen können dynamisch zur Laufzeit generiert werden), kein Precompiler nötig, kompatibel mit allen Java-IDEs und vielen Frameworks.</p>
                    <aside class="notes">JDBC (Java Database Connectivity) ist eine universelle API-Schnittstelle für die Programmiersprache Java. </aside>
                </section> 

                <section>
                    <h2>Driver</h2>
                    <div class="columns">
                    <div>
                        <p class="small">Jedes DBMS hat seinen eigenen JDBC-Treiber: MySQL, PostgreSQL, Oracle, ...</p>
                        <p class="small">&Rightarrow; Entsprechende Jar herunterladen und dem Java-Projekt zur Verfügung stellen</p>
                    </div>
                    <div>
                        <img src="img/6/driver_jar.png" alt="Driver Jar" style="width:25cm">
                    </div>
                    </div>

                    <p class="small">Nun kann über die Klasse <code>DriverManager</code> eine Verbindung aufgebaut werden.</p>
                    
                    <aside class="notes">Bis Java 1.6 war es nötig, den Treiber mittels <code>Class.forName("org.postgresql.Driver");</code> zu laden. Mittlerweile unterstützen die meisten JDBC-Treiber den Java Service Provider-Mechanismus, sodass der Treiber automatisch geladen wird, den die JVM im Classpath findet.</aside>
                </section>

                <section>
                    <h2>Connection</h2>
                    <pre><code class="hljava" data-sample='code/JDBC_Webshop/src/lecture/ZeigeProdukte.java#9-16,21,20,33-37' data-sample-mark="4,7,12" data-trim contenteditable></code></pre>
                <aside class="notes">Eine JDBC-URL besteht aus <code>jdbc:</code>, dem Treiber-Namen, der Adresse des DB-Servers, dem Datenbanknamen und evtl. weiteren optionalen Properties. <code>DriverManager.getConnection</code> stellt eine Verbindung zur Datenbank her und liefert ein <code>Connection</code>-Objekt zurück. Mittels dieses Objekts kann nun mit der Datenbank gearbeitet werden. Tritt ein Fehler beim Verbinden auf (z. B. falsches Passwort), wird eine <code>SQLException</code> geworfen. Auch andere Methoden, z.&nbsp;B. diejenigen, die Anfragen an die Datenbank schicken, werfen im Fehlerfall ebendiese Exception. </aside>
                </section>

                <section>
                    <h2>Statement und ResultSet</h2>
                    <pre><code class="hljava" data-sample='code/JDBC_Webshop/src/lecture/ZeigeProdukte.java#22-31' data-sample-mark="" data-trim contenteditable></code></pre>
                
                <aside class="notes">Um eine Anfrage an die Datenbank zu schicken, kann auf der vorhandenen <code>Connection</code>ein <code>Statement</code>-Objekt erzeugt werden. Eine Anfrage wird mit der <code>executeQuery</code>- oder <code>executeUpdate</code>-Methode an die Datenbank geschickt. Erstere liefert ein <code>ResultSet</code> zurück, zweitere dient zur Ausführung von <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, usw. und liefert die Anzahl der betroffenen Zeilen zurück.<br>
                Über ein <code>ResultSet</code> kann mittels der <code>next()</code>-Methode iteriert werden. <code>next()</code> liefert <code>false</code>, wenn wir am Ende der Ergebnismenge angekommen sind. Wie im Beispiel gezeigt, kann man mit einer While-Schleife Zeile für Zeile über das Ergebnis einer ausgeführten Anfrage iterieren. In jeder Iteration stehen einem Datentyp-spezifische Methoden bereit, um auf die Spaltenwerte der aktuellen Zeile zuzugreifen; entweder über die Position (beginnend mit 1) oder über das Spaltenlabel: <code>rs.getString(1)</code> und <code>rs.getString("bezeichnung")</code> liefert beides den Wert der Ergebnisspalte &quot;bezeichnung&quot;.</aside>
                </section>

                <section>
                    <h2>SQL-Injections</h2>
                    <div class="trackinfo"><i class="fas fa-headphones"></i> 100</div>
                    <div style="position: absolute; top: 20px; right:5px; font-size:160px"><i class="fas fa-exclamation-triangle red"></i></div>
                    <p class="small">Vorsicht beim Erzeugen von Query-Strings,<br>die Benutzereingaben beinhalten! (&rightarrow; <a href="https://www.xkcd.com/327/" target="_blank">xkcd.com/327</a>)</p>
                    <pre><code class="java" data-trim contenteditable data-sample='code/JDBC_Webshop/src/lecture/ZeigeProdukt_SQLInjection.java#23-24'></code></pre>
                    <p class="fragment small"><em>Geben Sie einen Hersteller ein: </em><input type="text" value="'; DROP TABLE webshop.produkte;" style="font-size: 22pt; width:13cm"></p>
                    <p class="fragment"><input type="text" value="' UNION (SELECT email||' '||passwort, NULL FROM webshop.kunden)" style="font-size: 22pt; width:25cm"></p>
                    <aside class="notes">Mit SQL-Injections lassen sich Sicherheitslücken ausnutzen, die es dem Benutzer ermöglichen, Datenbankbefehle einzuschleusen. Das hier gezeigte Programm ist gut gemeint, aber unsicher. Wenn der Benutzer Hersteller Calgonte eingibt, soll <code>SELECT ... WHERE hersteller = 'Calgonte'</code> ausgeführt werden. Dadurch, dass der Benutzerinput ohne Überprüfung und Maskierung von Sonderzeichen einfach so als Teil der Anfrage an den String drangehangen wird, ermöglicht man dem Anwender beliebige Anfragen auf der Datenbank auszuführen. Ersterer Hack würde die Produkte-Tabelle droppen. Dies kann man mit der JDBC-Parameter-Einstellung <code>allowMultiQueries=false</code> verhindern. Der zweite Hack würde dennoch funktionieren. Er ermöglicht dem Angreifer die Einsicht der E-Mail-Adressen und Passwörter aller Kunden. Durch die Eingabe von <code>' OR 1=1 --</code> findet man alle Produkte.</aside>
                </section>

                <section>
                    <h2>SQL-Injections</h2>
                    <div class="trackinfo"><i class="fas fa-headphones"></i> 101</div>
                    <div style="position: absolute; top: 20px; right:5px; font-size:160px"><i class="fas fa-exclamation-triangle red"></i></div>
                    <p class="small">Anderes Beispiel: Login-Formular</p>
                    <table class="small" style="border: none; background-color: gainsboro;">
                        <tr><td style="border: none;">E-Mail:</td style="border: none;"><td style="border: none;"><input style="font-size: 20pt; width: 10cm" value="peter@example.com' --"></td style="border: none;"></tr>
                        <tr><td style="border: none;">Passwort:</td style="border: none;"><td style="border: none;"><input style="font-size: 20pt; width: 10cm" value=""></td style="border: none;"></tr>
                        <tr><td colspan="2"><input type="button" style="width:100%; font-size:200%; " value="Einloggen"></td></tr>
                    </table>
                    <pre><code class="java" data-trim contenteditable data-sample='code/JDBC_Webshop/src/lecture/Login_SQLInjection.java#26-28'></code></pre>
                    <aside class="notes">Dadurch dass der Hacker hier mit dem Anführungszeichen den String abschließt und mittels <code>--</code> den Rest der Anfrage auskommentiert, ergibt sich eine gültige Anfrage, welche lediglich überprüft, ob es den Benutzer gibt und nicht, ob das Passwort stimmt. Im Endeffekt wird ausgeführt: <code>SELECT COUNT(*) FROM webshop.kunden WHERE email = 'peter@example.com' -- AND passwort = md5('')</code>. Alles ab <code>--</code> wird ignoriert.
                    <br>Die md5-Funktion erzeugt einen Hash aus dem Passwort (z. B. d41d8cd98f00b204e9800998ecf8427e), welcher mit dem gespeicherten Hash verglichen wird. Dies verhindert das Abspeichern von Klartext-Passwörtern. Da md5 jedoch unsicher ist, sollte stattdessen eher sha256 verwendet werden.</aside>
                </section>

                <section>
                    <h2>PreparedStatement</h2>
                    <p class="small">Ein PreparedStatement beinhaltet <code>?</code>-Platzhalter, die vor der Ausführung der Anfrage mit ihren Werten belegt werden.</p>
                    <pre><code class="java" data-trim contenteditable data-sample='code/JDBC_Webshop/src/lecture/ZeigeProdukt.java#21-26'></code></pre>
                    <p class="small">Vorteile: Verhindert SQL SQL-Injections, weniger fehleranfällig, Wiederverwenden von Anfragen, Sonderzeichen (z. B. <code>'</code>) werden automatisch maskiert.</p>
                    <aside class="notes">Bevor ein PreparedStatement mittels <code>executeQuery</code> oder <code>executeUpdate</code> ausgeführt wird, muss jeder <code>?</code>-Platzhalter mit einem Wert belegt werden. Dazu werden Datentyp-spezifische Methoden eingesetzt, z. B. hier <code>setString</code>. Dadurch, dass in diesem gesetzten String Sonderzeichen wie <code>'</code> automatisch maskiert werden (z. B. zu <code>''</code>), sind keine SQL Injections mehr möglich. Ein und dasselbe PreparedStatement kann mehrfach wiederverwendet werden, was auch eine erhöhte Performance zur Folge haben kann. Ein weiterer Vorteil ist, dass man sich unschöne und fehleranfällige Anfrageelemente wie <code>WHERE hersteller = '"+scan.nextLine()+"'"</code> erspart. Hier vergisst man gerne mal ein <code>'</code>.</aside>
                </section>

                <section>
                    <h2>executeUpdate</h2>
                    <pre><code class="java" data-trim contenteditable data-sample='code/JDBC_Webshop/src/lecture/NeuerKunde.java#17-27' data-sample-mark=""></code></pre>
                    <aside class="notes">Anders als <code>executeQuery</code> liefert <code>executeUpdate</code> kein ResultSet zurück, sondern einen Integer: die Anzahl der betroffenen Zeilen. Beim hier gezeigten INSERT ist dies stets eine 1, da nur eine Zeile eingefügt wird. Im Fehlerfall wird eine Exception geworfen. Bei einem UPDATE- oder DELETE-Kommando kann man am Rückgabewert der Methode sehen, wie viele Zeilen geändert oder gelöscht wurden. Neben <code>executeUpdate</code> und <code>executeQuery</code> gibt es auch noch die Methode <code>execute</code>. Diese liefert keinen Rückgabewert. Man verwendet sie z. B. für <code>CREATE TABLE</code> oder andere DDL-Kommandos.</aside>
                </section>

                <section>
                    <h3>DB-Metadaten-Zugriff mit JDBC</h3>
                    <h4>DatabaseMetaData</h4>
                    <pre><code class="java" data-trim contenteditable data-sample='code/JDBC_Webshop/src/lecture/MetadataExample.java#16-21' data-sample-mark=""></code></pre>
                    <h4>ResultSetMetaData</h4>
                    <pre><code class="java" data-trim contenteditable data-sample='code/JDBC_Webshop/src/lecture/MetadataExample.java#27-33' data-sample-mark=""></code></pre>
                    <aside class="notes">JDBC stellt Methoden bereit, um auf die Metadaten der Datenbank (z. B. Tabellen, Spalten einer Tabelle, ...) und auf Metadaten eines ResultSets zuzugreifen.</aside>
                </section>

                <section>
                    <h2>Routinen</h2>
                    <div class="trackinfo"><i class="fas fa-headphones"></i> 102</div>
                    <p>Benutzerdefinierte Routinen sind in der DB gespeicherte Datenbankobjekte (wie Tabellen und Views):</p>
                    <ul>
                        <li><b>Prozeduren</b> tun etwas</li>
                        <li><b>Funktionen (UDF)</b> liefern einen Ergebniswert</li>
                        <li><b>Tabellenfunktionen</b> liefern eine Tabelle</li>
                        <li><b>Methoden</b> gehören zu einem User-defined Datatype</li>
                    </ul>
                    <p class="small">Routen haben einen Namen und Eingabeparameter.</p>
                    <aside class="notes">Die meisten Datenbankmanagementsysteme erlauben die Erstellung von Routinen in einer Programmiersprache. In PostgreSQL heißt diese Sprache PL/pgSQL (Prozedurale Spracherweiterung für PostgreSQL). Neben SQL-Anfragen (SELECT, INSERT, ...) gibt es auch IF-Blöcke, FOR-Schleifen, usw. Methoden werden in dieser Vorlesung nicht behandelt. Durch in der Datenbank gespeicherte Routinen werden unnötige Anfragen zwischen Client-Anwendung und DB-Server vermieden. Vor allem solche Anfragen, die nur Zwischenergebnisse abrufen, welche in Folgeanfragen verwendet werden.
                    </aside>
                </section>

                <section>
                    <h2>PG/plSQL</h2>
                    <h4>Block:</h4>
                    <pre><code class="hlsql dont_execute_sql" data-trim contenteditable>
                        [ DECLARE 
                        -- hier können Variablen definiert werden ]
                        BEGIN
                        -- Anweisungen ...
                        END
                    </code></pre>
                    <h4>Kontrollstrukturen:</h4>
                        <pre><code class="hlsql dont_execute_sql" data-trim contenteditable>
                            IF ... THEN ... [ELSE ...] END;
                            WHILE ... LOOP ... END LOOP;
                            LOOP ... EXIT WHEN ...; END LOOP;
                            FOR ... IN ... .. ... LOOP ... END LOOP;
                            FOR ... IN 'SELECT ...' LOOP ... END LOOP;
                        </code></pre>
                </section>

                <section>
                    <h2>Stored Procedures</h2>
                    <div class="trackinfo"><i class="fas fa-headphones"></i> 103</div>
                    <pre><code class="hlsql dont_execute_sql" data-trim contenteditable>
CREATE OR REPLACE FUNCTION alles_leeren() RETURNS void AS
$$ BEGIN
 TRUNCATE bewertungen CASCADE;
 TRUNCATE produkte CASCADE;
 TRUNCATE hersteller CASCADE;
 TRUNCATE kunden CASCADE;
END $$ LANGUAGE plpgsql;</code></pre>

<pre><code class="hlsql dont_execute_sql" contenteditable>SELECT alles_leeren();</code></pre>

                <aside class="notes">In diesem einfachen Beispiel hat unsere Prozedur <code>alles_leeren</code> keine Eingabeparameter (daher die leeren Klammern <code>()</code>), wir definieren keine Variablen und verwenden auch keine Kontrollstrukturen oder Schleifen. Es werden lediglich vier <code>TRUNCATE</code>-Kommandos ausgeführt. In PostgreSQL sind Prozeduren <code>FUNCTION</code>-Objekte mit dem Rückgabetyp <code>void</code>. Man ruft sie in einem <code>SELECT</code>-Kommando ohne <code>FROM</code>-Klausel auf. Seit PostgreSQL 11 gibt es jedoch auch <code>CREATE PROCEDURE</code>, welche dann mit einem <code>CALL</code>-Befehl aufgerufen werden (siehe übernächste Folie). In anderen DBMS werden Prozeduren mit einem <code>EXECUTE</code>-Befehl ausgeführt.<br>Schreibt man <code>CREATE OR REPLACE</code> statt einfach nur <code>CREATE</code>, wird die Funktion überschrieben, falls sie schon existiert.</aside>
                </section>
            <section>
                <h3>RAISE NOTICE</h3>
                <p class="small"><code>RAISE NOTICE</code> gibt einen Infotext auf der Konsole aus.</p>
                <pre><code class="hlsql dont_execute_sql" data-trim contenteditable>
CREATE OR REPLACE FUNCTION hallo() RETURNS void AS $$
DECLARE
    x INT := 5;
BEGIN
    RAISE NOTICE 'Hallo!!!';
    RAISE NOTICE 'x ist %', x;
END $$ LANGUAGE plpgsql;</code></pre>

<pre><code class="hlsql dont_execute_sql" contenteditable>SELECT hallo();</code></pre>
            <img src="img/6/dbeaver_notice.png" alt="DBeaver Serverausgabe anzeigen" style="width:12cm">
            <aside class="notes">Verwendet man im Notice %-Platzhalter, kann man deren Werte als zusätzliche Parameter übermitteln. Diese Folie zeigt auch, wie man Variablen deklariert. Bei <code>x INT := 5;</code> hat x den Wert 5. Mit <code>x INT</code> würde man lediglich die Variable x ohne Wert definieren, damit man diesen später zuweisen kann.</aside>
            </section>

            

            <section>
                <h2>Stored Procedures</h2>
                <pre><code class="hlsql dont_execute_sql" data-trim contenteditable>
CREATE PROCEDURE bestelle_produkt(_kundennr INT, 
                                  _produktnr INT) AS $$
DECLARE
   _bestellnr INT;
BEGIN
  SELECT MAX(bestellnummer)+1 INTO _bestellnr FROM bestellungen;
  RAISE NOTICE 'Bestellnummer: %', _bestellnr;
  INSERT INTO bestellungen(bestellnummer, kundennummer, zeit, 
    preis) VALUES (_bestellnr, _kundennr, current_timestamp,
    (SELECT preis FROM produkte WHERE produktnr=_produktnr));
  INSERT INTO bestellungen_positionen (bestellnummer, 
    produktnummer, anzahl) VALUES (_bestellnr, _produktnr, 1);
  COMMIT;
END $$ LANGUAGE plpgsql;</code></pre>

<pre><code class="hlsql dont_execute_sql" data-trim contenteditable>CALL bestelle_produkt(5, 17);</code></pre>
                    
            <aside class="notes">Anders als bei <code>CREATE FUNCTION</code> werden bei PostgreSQL im <code>CREATE PROCEDURE</code> auch Transaktionen (<code>COMMIT</code> / <code>ROLLBACK</code>) unterstützt. Damit wird garantiert, dass beide hier dargestellten <code>INSERT</code>s ausgeführt werden (oder keines) und dass die mit MAX ermittelte neue Bestellnummer auch in jedem Fall gültig ist, auch wenn andere Transaktionen parallel Bestellungen einfügen (&rightarrow; Phantomproblem).</aside>
            </section>
            
            <section>
                <h3>Eingabeparameter</h3>
                <p class="small">Zugriff über den Namen oder die Position (<code>$1</code>, ...)</p>

<pre><code class="hlsql dont_execute_sql" data-trim contenteditable>CREATE OR REPLACE PROCEDURE test(i int, s VARCHAR) AS $$
BEGIN
 RAISE NOTICE 'i ist %', i;     -- i ist 99
 RAISE NOTICE 's ist %', $2;    -- s ist Tomate
END $$ LANGUAGE plpgsql;</code></pre>

<pre><code class="hlsql dont_execute_sql" contenteditable>CALL test(99, 'Tomate');</code></pre>
<aside class="notes"><code>$2</code> steht hier für den zweiten Parameter, also für <code>s</code>. Wir verwenden in den Beispielen aber auch oft Variablennamen, die mit einem Unterstrich beginnen (z. B. <code>_produktnr</code>), damit man sie nicht mit Spaltennamen oder ähnlichem verwechselt.</aside>
</section>

<section>
    <h2>Funktionen</h2>
    <div class="trackinfo"><i class="fas fa-headphones"></i> 103</div>
    <p>UDF = User-defined Function</p>

    <pre><code class="hlsql dont_execute_sql" contenteditable>CREATE OR REPLACE FUNCTION addieren(int, int) RETURNS INT AS
$$ BEGIN RETURN $1+$2; END $$ LANGUAGE plpgsql;</code></pre>

    <pre><code class="hlsql dont_execute_sql" contenteditable>SELECT addieren(5,4);</code></pre>

    <pre class="fragment"><code class="hlsql dont_execute_sql" contenteditable>SELECT *, addieren(sterne, 1) FROM bewertungen;</code></pre>

    <aside class="notes">Funktionen haben beliebig viele Eingabeparameter und liefern genau einen Rückgabewert zurück. Der Datentyp des Rückgabewerts steht oben hinter <code>RETURNS</code>. Mit einem <code>RETURN</code>-Kommando terminiert die Funktion und erzeugt die Rückgabe. Man kann die Funktion genau wie eingebaute SQL-Funktionen (UPPER, MD5, ...) in SELECT-Anfragen mit und ohne FROM-Klausel verwenden, aber auch in INSERT, UPDATE, etc. Die hier dargestellte Funktion addiert zwei Zahlen. Die Eingabeparameternamen kann man wie hier gezeigt einfach weggelassen, wenn man auf sie lediglich mittels <code>$1</code> etc. zugreift.</aside>
</section>

<section>
    <h3>Exceptions werfen und behandeln</h3>

    <pre><code class="sql dont_execute_sql" data-trim contenteditable>
CREATE FUNCTION dividieren(float, float) RETURNS float AS
$$ BEGIN 
RETURN $1/$2; 
EXCEPTION WHEN OTHERS THEN 
    RAISE EXCEPTION 'Divisor darf nicht 0 sein!';
END $$ LANGUAGE plpgsql;</code></pre>
    
    <aside class="notes">Hinter <code>EXCEPTION WHEN</code> steht der Name einer Exception, die abgefangen werden soll. <code>OTHERS</code> fängt alle sonstigen Fehler ab. Mit <code>RAISE EXCEPTION</code> wird ein Programm unterbrochen und die entsprechende Fehlermeldung an den Client zurückgegeben.</aside>
</section>

<section>
    <h3>Volatilitäts-Kategorien</h3>
    <pre><code class="hlsql dont_execute_sql" contenteditable>CREATE OR REPLACE FUNCTION addieren(int, int) RETURNS INT AS
$$ BEGIN RETURN $1+$2; END $$ LANGUAGE plpgsql IMMUTABLE;</code></pre>
    
        <h4><code>VOLATILE</code> (Standard)</h4>
        <p class="small" style="margin-top: -7mm;">Funktion darf alles: DB verändern und bei gleichen Parameterwerten unterschiedliche Ergebnisse liefern.</p>
        
        <h4 style="margin-top: -4mm;"><code>STABLE</code></h4 style="margin-top: -2mm;">
        <p class="small" style="margin-top: -7mm;">Funktion darf die DB nicht verändern und muss innerhalb des gleichen Statements bei gleichen Parameterwerten das gleiche Ergebnis liefern.</p>
        
        <h4 style="margin-top: -4mm;"><code>IMMUTABLE</code></h4>
        <p class="small" style="margin-top: -7mm;">Funktion darf die DB nicht verändern und muss bei gleichen Parameterwerten das gleiche Ergebnis liefern.</p>
    </ul>
    <aside class="notes">Wenn eine Funktion als <code>STABLE</code> oder <code>IMMUTABLE</code> deklariert wird, kann der Datenbank-Optimierer Ergebnisse der Funktion wiederverwenden, ohne die Funktion nochmals aufzurufen. Eine Funktion <code>get_hersteller_land</code>, die beispielsweise eine <code>SELECT</code>-Anfrage an eine Tabelle schickt, um das Land eines Herstellers zu ermitteln, ist <code>STABLE</code>, da sie innerhalb einer Anfrage, in der sie aufgerufen wird, für den gleichen Hersteller das gleiche Land liefern würde.</aside>
</section>

<section>
    <h2>Tabellenfunktionen</h2>
    <pre><code class="hlsql dont_execute_sql" contenteditable>CREATE OR REPLACE FUNCTION produkte_von(VARCHAR) RETURNS TABLE
(produktnr INT, bezeichnung VARCHAR(100), 
 preis DECIMAL(9,2), hersteller VARCHAR(50)) AS $$ 
SELECT produktnr, bezeichnung, preis, hersteller 
FROM produkte WHERE hersteller = $1 
$$ LANGUAGE sql;
</code></pre>
        
            <pre><code class="hlsql dont_execute_sql" contenteditable>SELECT * FROM produkte_von('Calgonte');</code></pre>
        
        <aside class="notes">Tabellenfunktionen liefert eine Tabelle zurück mit beliebig vielen Zeilen. Die Spalten und deren Typen werden im <code>CREATE FUNCTION</code>-Kommando im <code>RETURNS TABLE</code>-Teil definiert. Genau wie eine View wird eine Tabellenfunktion in der <code>FROM</code>-Klausel einer SELECT-Anfrage aufgerufen. Eine Tabellenfunktion ist quasi eine View mit Parametern.</aside>
</section>

<section>
    <h2>Trigger</h2>
    <div class="trackinfo"><i class="fas fa-headphones"></i> 104</div>
    <p>Wenn ...</p>
    <div class="columns">
        <div><ul>
            <li>BEFORE</li>
            <li>AFTER</li>
            <li>INSTEAD OF</li>
        </ul></div>
        <div><ul>
            <li>INSERT</li>
            <li>UPDATE</li>
            <li>DELETE</li>
        </ul></div>
        <div><ul>
            <li>ON &lt;tabelle&gt;</li>
            <li>ON &lt;view&gt;</li>
        </ul></div>
    </div>

    <p>dann ...</p>

    <aside class="notes">Mittels Triggern können Aktionen ausgeführt werden, jedesmal wenn das festgelegte Ereignis eintritt. Nach einem INSERT in die Produkttabelle kann automatisch der Hersteller eingefügt werden, falls es ihn noch nicht gibt. Bevor der Preis eines Produkts geändert wird, wird überprüft, ob diese Änderung auch in Ordnung ist. Wenn der Preis um mehr als 20% erhöht wird, soll ein Fehler kommen. Wenn ein INSERT auf einer View gemacht wird, sollen stattdessen INSERTs in gewisse Tabellen gemacht werden. Solche Abläufe können mittels Trigger definiert werden.</aside>
    
</section>

    <section>
        <h3>Trigger in PostgreSQL</h3>
        <h4>Triggerfunktion</h4>
        <ul class="small">
            <li>Definiert die auszuführende Aktion</li>
            <li><code>CREATE FUNCTION ... RETURNS TRIGGER ...</code></li>
        </ul>
        <p/>
        <h4>Trigger</h4>
        <ul class="small">
            <li>Definiert den eigentlichen Trigger (die Wenn-Falls-Dann-Bedingung)</li>
            <li><code>CREATE TRIGGER ... {BEFORE | AFTER | INSTEAD OF}<br>{INSERT | UPDATE | DELETE} ON ...<br>FOR EACH {ROW | STATEMENT} [WHEN (...)]<br> EXECUTE PROCEDURE ...();</code></li>
        </ul>
        <aside class="notes">In PostgreSQL wird zunächst eine Triggerfunktion definiert. Diese ist ähnlich zu einer Funktion mit dem Returns-Type <code>void</code>. In dieser Triggerfunktion hat man jedoch Zugriff auf die eingefügte, geänderte, bzw. gelöschte Zeile und man kann diese sogar noch modifizieren oder die Operation noch aufhalten.<br>
        Trigger können auch sogenannte ECA-Regel implementieren. ECA steht für Event, Condition, Action. Wenn also ein Ereignis eintritt, soll - falls die Bedingung erfüllt ist - das Ereignis ausgeführt werden. Die Bedingung lässt sich in PostgreSQL mittels einer optionalen <code>WHEN</code>-Bedingung festlegen.</aside>
    </section>

    <section>
        <h3>AFTER INSERT</h3>
        <p class="small">Nachdem das neue Tupel eingefügt wurde, soll noch etwas gemacht werden.</p>
        <pre><code class="hlsql dont_execute_sql" contenteditable data-trim>
CREATE FUNCTION produkte_trigger() RETURNS TRIGGER AS
$$ BEGIN
IF (NEW.hersteller IS NOT NULL AND NOT EXISTS 
  (SELECT * FROM hersteller WHERE firma = NEW.hersteller)) THEN
  INSERT INTO hersteller (firma) VALUES(NEW.hersteller);
END IF;
RETURN NEW;
END; $$ LANGUAGE plpgsql;</code></pre>

<p class="small"><code>NEW</code> bietet Zugriff auf die neu eingefügte Zeile.</p>
    

    <pre><code class="hlsql dont_execute_sql" contenteditable data-trim>
CREATE TRIGGER produkte_trigger AFTER INSERT ON produkte
FOR EACH ROW EXECUTE PROCEDURE produkte_trigger();</code></pre> 

<aside class="notes">Immer wenn ein INSERT auf die Produkttabelle gemacht wird, feuert der Trigger. Er sorgt dafür, dass der Hersteller in die Herstellertabelle eingefügt, wenn er noch nicht drin ist. Über das Objekt <code>NEW</code> hat man innerhalb des Triggers Zugriff auf die Attributwerte der neu eingefügten Zeile.</aside>
</section>

<section>
    <h3>AFTER INSERT</h3>
    <pre><code class="hlsql dont_execute_sql" contenteditable data-trim>
INSERT INTO produkte VALUES(1000, 'Kuchen', 2.00, 'Kuchenpeter');
    </code></pre> 
    <p class="fragment small" style="color:red" data-fragment-index="1">[23503]: ERROR: insert or update on table "produkte" violates foreign key constraint "produkte_hersteller_fkey"
        Detail: Key (hersteller)=(Kuchenpeter) is not present in table "hersteller".</p>
    
    <ul class="fragment small" data-fragment-index="2">
        <li>Entweder Trigger auf <code>BEFORE INSERT</code> ändern</li>
        <li>oder das Fremdschlüssel-Constraint auf <code>DEFERRED</code> setzen:</li>
    </ul>

    <pre class="fragment" data-fragment-index="2"><code class="hlsql dont_execute_sql" contenteditable data-trim>
ALTER TABLE webshop.produkte ADD CONSTRAINT 
produkte_hersteller_fkey FOREIGN KEY (hersteller) 
REFERENCES hersteller(firma) ON UPDATE CASCADE 
INITIALLY DEFERRED;</code></pre>

<aside class="notes">Ändern wir den Trigger auf <code>BEFORE INSERT</code>, wird die Prozedur, die den Hersteller einfügt, ausgeführt, bevor die neue Zeile in die Produkttabelle eingefügt wird. Der Hersteller ist hier der Parent-Record und das Produkt der Child-Record. Der Parent muss vorher existieren, bevor der Child-Record existiert.<br>
Als Alternative kann die Überprüfung des Fremdschlüssel-Constraints auch auf <code>DEFERRED</code> (verzögert) setzen. Der Standard ist <code>IMMEDIATE</code> - eine sofortige Überprüfung. Bei <code>DEFERRED</code> wird das Constraint erst zum Ende der Transaktion überprüft. In unserem Fall führt dies zum Erfolg, da zum Ende der Transaktion der zuvor nicht existierende Hersteller zwischenzeitlich durch den Trigger eingefügt wurde.</aside>
</section>

<section>
    <h3>BEFORE INSERT / UPDATE / DELETE</h3>
    <div class="trackinfo"><i class="fas fa-headphones"></i> 105</div>
    <p class="small">Mit einem <code>BEFORE</code>-Trigger kann man das einzufügende Tupel modifizieren oder das <code>INSERT</code> / <code>UPDATE</code> / <code>DELETE</code> ablehnen.</p>

<pre><code class="hlsql dont_execute_sql" contenteditable data-trim>
CREATE OR REPLACE FUNCTION preis_trigger() RETURNS TRIGGER AS $$ 
DECLARE anz_gratis_produkte INT;
BEGIN
IF (NEW.preis < 0) THEN NEW.preis = 0; END IF;
SELECT COUNT(*) INTO anz_gratis_produkte 
FROM produkte WHERE preis = 0;
IF (NEW.preis = 0 AND anz_gratis_produkte >= 3) THEN
 RAISE EXCEPTION 'Zu viele kostenlose Produkte!';
END IF;
RETURN NEW;
END; $$ LANGUAGE plpgsql;</code></pre>

<pre><code class="hlsql dont_execute_sql" contenteditable data-trim>
CREATE TRIGGER preis_trigger BEFORE INSERT OR UPDATE ON produkte
FOR EACH ROW EXECUTE PROCEDURE preis_trigger();</code></pre>
<aside class="notes">Bei einem <code>BEFORE INSERT</code>-Trigger kann man einzufügende Tupel noch abändern, bevor es tatsächlich in die Tabelle eingefügt wird. Hier wird der Preis auf 0 gesetzt, sollte jemand versuchen, ein Produkt mit negativen Preis einzufügen. Außerdem überwacht der Trigger, dass es nie mehr als drei kostenlose Produkte gibt. Ein INSERT oder UPDATE wird abgelehnt, wenn es dieses Constraint verletzen sollte.</aside>
</section>

<section>
    <h3>OLD / NEW</h3>
    <ul>
        <li><code>INSERT</code>-Trigger: Zugriff auf <code>NEW</code></li>
        <li><code>DELETE</code>-Trigger: Zugriff auf <code>OLD</code></li>
        <li><code>UPDATE</code>-Trigger: Zugriff auf <code>OLD</code> und <code>NEW</code></li>
    </ul>
    <pre><code class="hlsql dont_execute_sql" contenteditable data-trim>
CREATE OR REPLACE FUNCTION preiserhoehung_trigger() 
RETURNS TRIGGER AS $$ 
BEGIN
IF (NEW.preis > OLD.preis*1.1) THEN
 RAISE EXCEPTION 'Preiserhöhung um mehr als 10%% nicht erlaubt!';
END IF;
RETURN NEW;
END; $$ LANGUAGE plpgsql;</code></pre>
<aside class="notes">Beim INSERT hat man in der Triggerfunktion Zugriff auf <code>NEW</code> (die eingefügte Zeile), beim DELETE auf <code>OLD</code> (die gelöschte Zeile) und beim UPDATE auf <code>OLD</code> und <code>NEW</code>. <code>OLD</code> bietet Zugriff auf den vorherigen Zustand des Tupels vor der Änderung, <code>NEW</code> auf den Zustand nach der Änderung.<br>
Hier wurde <code>10%%</code> geschrieben, da <code>%</code> als Platzhalter steht, der durch einen Wert ersetzt wird (siehe Folie zu RAISE NOTICE). <code>%%</code> wird durch <code>%</code> ersetzt.</aside>
</section>

<section>
    <h3>FOR EACH ROW / STATEMENT</h3>
    <h4>FOR EACH ROW</h4>
    <ul>
        <li>Triggerfunktion wird für jedes eingefügte / gelöschte / geänderte Tupel einmal aufgerufen</li>
        <li>Zugriff auf das Tupel mittels <code>NEW</code> bzw. <code>OLD</code></li>
    </ul>
    <p/>
    <h4>FOR EACH STATEMENT</h4>
    <ul>
        <li>Triggerfunktion wird für das gesamte INSERT / UPDATE / DELETE-Statement nur einmal aufgerufen</li>
        <li>Kein direkter Zugriff auf die Tupel</li>
    </ul>
    <aside class="notes">Der Trigger, der überprüft, dass es stets nie mehr drei kostenlose Produkte gibt, könnte auch vom Typ <code>FOR EACH STATEMENT</code> sein. Dies würde die Überprüfung bei großen Änderungsmengen deutlich beschleunigen, da sie nur einmal und nicht für jede geänderte Zeile erfolgen muss.</aside>
</section>

<section>
    <h3>INSTEAD OF-Trigger</h3>
    <div class="trackinfo"><i class="fas fa-headphones"></i> 106</div>
    <pre><code class="hlsql dont_execute_sql" contenteditable data-trim>INSERT INTO meine_view VALUES (...)</code></pre>
    <ul class="small">
        <li>Nur in simple Views Projektion-Selektion-Views darf ein INSERT/UPDATE/DELETE erfolgen</li>
        <li>Mittels einer <code>CHECK OPTION</code> kann überprüft werden, dass das Tupel auch das WHERE-Prädikat der View erfüllt.</li>
        <li><code>INSTEAD OF</code>-Trigger ermöglichen INSERT/UPDATE/DELETE auf jeder View.</li>
    </ul>
    <pre class="fragment"><code class="hlsql dont_execute_sql" contenteditable data-trim>
CREATE TRIGGER meine_view_trigger INSTEAD OF INSERT ON meine_view
FOR EACH ROW EXECUTE PROCEDURE meine_view_trigger();        
    </code></pre>

    <aside class="notes"><code>INSTEAD OF</code>-Trigger sind nur für Sichten gedacht. Jedes mal, wenn jemand ein INSERT / UPDATE / DELETE auf eine Sicht macht, soll stattdessen die Trigger-Aktion ausgelöst werden.</aside>
</section>

<section>
    <h3>INSTEAD OF-Trigger</h3>
    <pre style="width: 95%;"><code class="hlsql dont_execute_sql" contenteditable data-trim>
CREATE VIEW meine_view AS
SELECT p.produktnr, p.bezeichnung, p.preis, p.hersteller, h.land
FROM produkte p JOIN hersteller h ON p.hersteller=h.firma;
</code></pre>

<pre class="fragment" style="width: 95%;"><code class="hlsql dont_execute_sql" contenteditable data-trim>
CREATE OR REPLACE FUNCTION meine_view_trigger() 
RETURNS TRIGGER AS $$ 
BEGIN
INSERT INTO hersteller (firma, land)
 VALUES (NEW.hersteller, NEW.land)
 ON CONFLICT (firma) DO UPDATE SET land=EXCLUDED.land;
INSERT INTO produkte (produktnr, bezeichnung, preis, hersteller)
 VALUES (NEW.produktnr, NEW.bezeichnung, NEW.preis, NEW.hersteller);
RETURN NEW;
END; $$ LANGUAGE plpgsql;</code></pre> 

<aside class="notes">Die gezeigte View führt eine Denormalisierung der beiden Tabellen Produkte und Hersteller aus, also einen Join. Der Trigger sorgt dafür, dass ein INSERT in diese View aufgeteilt wird in zwei INSERT-Kommandos. Zunächst wird der Hersteller eingefügt. Falls es ihn schon gibt, wird sein Land angepasst. Im Anschluss erfolgt das Einfügen des Produktes.</aside>
</section>

                        </div>
                    </div>
            
                    <script src="reveal.js/js/reveal.js"></script>
                    <script src="lib/jquery.js"></script>
                    <script src="lib/lodash.js"></script>
                    <script src="lib/backbone.js"></script>
                    <script src="lib/joint.min.js"></script>
            
                    <script src="src/init_reveal.js"></script>
            
                    <script>
                    if(window.location.search.match( /print-pdf/gi )) {
                            document.getElementById('header').style="display:none";
                            document.getElementById('footer').style="display:none";
                    }
                    </script>
            
            
                </body>
            </html>
